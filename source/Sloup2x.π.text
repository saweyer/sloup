// Text of project Sloup2x.¹ written on 11/10/01 at 8:54 AM// Beginning of text file reloFix// reloFix// Copyright 1997-2001. S. Weyer. All Rights Reserved Worldwide// this can be incorporated in various package exporting utilities// if acknowledge is provided in product description, as well as a link// to my Newton page://    http://www.kagi.com/weyer//* interested developers:Dan Rowley <dan@newts.com>Robert Bruce <rbruce@tactile.com>Reinhold Schoeb <schoeba@str.daimler-benz.com>Brian K. Ogilvie  <BKOgilvie@aol.com>*//*!!!b. flags changes related to unit references.Here is an improved version of reloFix. It now handles multipart packages-- unless these are 2.x packages that have formal "relocation headers"(that's something I could fix in a future version since it's documentedthough messy -- no current plans).  If the package is copyProtected(unless overridden by a new param) or has 2.x relo headers, reloFix nowreturns NIL instead of modified pkg.  I documented/relaxed more assumptions.Other changes: you do not need to copy the original package (reloFix does this).You do not need to supply dummy offset or relo (since there are two methods now);you do not need to put nextFlush or reloFix in your app base -- see example.If you turn on debugging, you'll print some package and part info.It appears to correctly convert NewtWorks (a 2-part package);I fixed/reinstalled via Sloup.It rejects NetHopper (relo headers), Internet Enabler (relo headers, copy protected).suggested usage:obtain a package, e.g.,	pkg := GetPkgRef(pkgName, store);or	pkg := entry.package (from Extras target cursor)	newpkg := {		nextFlush:	kVBOFlush,		reloFix: 	kReloFix,		reloFixObj: kReloFixObj,		}:reloFix(pkg, nil);	// orig pkg; don't copy if copyProtected	returns copied&fixed pkg; otherwise nil		if pkg is copyProtected and you specified copyOk=nil		if pkg has 2.x "relocation headers"*/DeclareGlobalFn('ClearVBOCache,1);DefineGlobalConstant('kVBOFlush, 24*1024);	// every 24K or so? ( < 32K?) constant kWordSize  := 65536;constant kByteSize  := 256;constant kByteSize3 := 65536 * 256;DefineGlobalConstant('kExtractNum3, // extract 3 digit number (inline for speed?)func NATIVE (pkg, INT offset)ExtractByte(pkg, offset) 	* kWordSize +ExtractByte(pkg, offset+1) 	* kByteSize +ExtractByte(pkg, offset+2));DefineGlobalConstant('kReloFix,func NATIVE (pkg, copyOk)/*pkg: 	a package VBO (original ok; this copies if necessary)copyOk:	copy copyProtected packages?returns	modified pkg	NIL (if copyProtected & not copyOk, or unhandled 2.x relocation info)this fixes relocation info in multiple parts in a 1.x package,or a 2.x package (without relocation header info)*/begin	local INT numParts 	:= ExtractWord(pkg, 50); 	// assume # parts < 65536(kWordSize)	local INT flagByte1 := ExtractByte(pkg, 12);	local okrelo :=		Band(flagByte1, 0x04) = 0					// relocation header flag off?		and (copyOk or Band(flagByte1, 0x40) = 0);	// copy protected flag off?if kDebugOnthen begin	local INT i;	local s;	for i := 0 to 7	do s := s & Chr(ExtractByte(pkg,i));	Print("format:" && s);	// usually(only?): package0 or package1	Print("numParts:" && numParts);	if Band(flagByte1, 0x40)<>0 then Print("COPY PROTECTED!");	if Band(flagByte1, 0x04)<>0 then Print("RELOCATION INFO!");	endelse if not okrelo	// copyprotected or 2.x relo info not handled yetthen return NIL;	local INT offset, partNum, partIndex, obj, partOffset := ExtractWord(pkg, 46);	local ARRAY relo := Array(4, NIL);	// !!!b	local part, any;	local ARRAY imports := Array(numParts, '[]);	// collect all import declarations (if any)	foreach partNum,part in GetPkgRefInfo(pkg).parts	do  if isArray(part._ImportTable)		then imports[partNum] := any := Clone(part._ImportTable);	if any and okrelo	then begin		local exports := {}, epkg, entry, objs;		local INT i;		// collect all export objects		foreach epkg in GetPackages()		do  if epkg.store and IsPackageActive(epkg := GetPkgRef(epkg.title,epkg.store))			then foreach part in GetPkgRefInfo(epkg).parts				 do if isFrame(part) and isArray(part._ExportTable)					then foreach entry in part._ExportTable					 	 do exports.(entry.name) := entry.objects;	// assume unique?? version?		// replace import declarations with object refs		foreach part in imports		do  foreach i,entry in part			do  if objs := exports.(entry.name)				then part[i] := foreach obj in objs collect RefOf(obj);//Print(imports);		exports := nil; // not needed		end;	if okrelo	then begin // copy, setup//if kDebugOn then//Print("len:" && Length(pkg));		gc();		pkg := BinaryMunger(			GetDefaultStore():NewCompressedVBO('package, Length(pkg), kTextCompander,nil),0,nil,			pkg,0,nil);		ClearVBOCache(pkg);	// do this now		end;	for partNum := 0 to numParts-1	do begin		partIndex := 52 + (partNum * 32);	// each part header is 32 bytes long		// first object of each part is an array with 1 element (a part frame)		offset := partOffset + call kExtractNum3 with (pkg, partIndex+1);if kDebugOnthen beginPrint("part:" && partNum);Print("offset:" && offset);Print("part length:" &&			// uncompressed? size: 8-11	call kExtractNum3 with (pkg, partIndex+9)); Print("part type:" &&			// type: 12-15 (assumes null term in 16!)	ExtractCString(pkg, partIndex+12)); Print("part kind:" &&			// flags: 20-23'["protocol", "frames", "raw", "??"][BAND(ExtractByte(pkg,partIndex+23),0x3)]);end;		if partNum=0 and okrelo		then begin			// skip header,0,type(+12)			// assume [0] points to next object (+4) in pkg			// keep relo in array of 4 bytes -- "long" is too big; (words messy)			// this appears to be constant throughout entire normal package			obj := offset+16;			relo[0] := ExtractByte(pkg,offset+12);			relo[1] := ExtractByte(pkg,offset+13) - (obj div kWordSize);			obj := obj mod kWordSize;			relo[2] := ExtractByte(pkg,offset+14) - (obj div kByteSize);			relo[3] := ExtractByte(pkg,offset+15) - (obj mod kByteSize) - 1;  // for obj ptr//if kDebugOn then//begin Write("relo: "); Print(relo); end;			end;		if okrelo		then :reloFixObj(pkg, offset, relo, imports[partNum]);	// !!!b		end;	if okrelo	then begin		ClearVBOCache(pkg);	// one last time		pkg;		end;	//else NILend);DefineGlobalConstant('kReloFixObj,func NATIVE (pkg, INT offset, ARRAY relo, ARRAY imports)begin // fix objects within a part//Print(offset);	// DATA (0x40), ARRAY (0x41), FRAME (0x43)	local INT ctype := ExtractByte(pkg, offset+3);	local INT clen :=		if ctype = 0x40 // DATA		then 12 // only check type		else call kExtractNum3 with (pkg, offset);	// inline?	local INT i, obj, plen := Length(pkg);	// ,p	local INT byte0, byte1, byte2, byte3;	local INT relo0 := relo[0], relo1 := relo[1], relo2 := relo[2], relo3 := relo[3]; // cache	for i := offset+8 to offset+clen-4 by 4	do	if BAND(byte3 := ExtractByte(pkg, i+3), 0x3) = 1	// obj ptr?			//and ExtractByte(pkg,i) <> 0 // not already relocated? (assumes pkg < 17M)	  	then begin			byte0 := ExtractByte(pkg, i);			byte1 := ExtractByte(pkg, i+1);			byte2 := ExtractByte(pkg, i+2);			obj := (byte0 << 22) + (byte1 << 14) + (byte2 << 6) + (byte3 >> 2);//Print(i & $: && obj);			if obj >= plen or obj < 0			then begin//Print([byte0,byte1,byte2,byte3]);//Print([byte0-relo0,byte1-relo1,byte2-relo2,byte3-relo3]);				obj :=					(byte0 - relo0) * kByteSize3 +					(byte1 - relo1) * kWordSize +					(byte2 - relo2) * kByteSize +					(byte3 - relo3);				//obj := 0;				//for p := 0 to 3				//do obj := obj*kByteSize + ExtractByte(pkg,i+p) - relo[p];//if kDebugOn then//Print(i & $: && obj);				if obj < 0	// !!!b. a unit reference???				then if Length(imports)					then begin						local INT tableNum, uref :=							byte0 * kByteSize3 + byte1 * kWordSize +							byte2 * kByteSize  + byte3;//Print("unit ref?" && uref);						local objs, pos;						foreach tableNum,objs in imports						do if pos := SetContains(objs, uref)							then begin//Print("table:" && tableNum+2 & $; && "index:" && pos);								StuffLong(pkg, i,						       		((tableNum+2) << 14) + (pos << 2) + 0x3);						       	break uref := nil;						       	end;						if uref						then Print("import not found!");						end					else Print("no import table!?")					//obj negative so no recursive				else StuffLong(pkg, i, obj);				if i > nextFlush				then begin					ClearVBOCache(pkg);					nextFlush := nextFlush + kVBOFlush;					end;				obj := obj-1; 		// make ptr an offset				// any "normal" package appears to first save a (forward) pointer to an object				// and later the object itself; other references to obj might be back (ok).				// if there is a package that doesn't re-upload properly				// you could comment out the following test, though since it would (re)check				// validity of every pointer in an array or frame, it could slow things down						//if obj > offset then		// needs fixing only if later in package? assumes first ref is forward				if obj > 0 and obj < plen	// !!!a				then :reloFixObj(pkg, obj, relo, imports);				end;			end;		//else if Band(byte3,0x3)=3		//then Print(i & ": magic" && ExtractLong(pkg,i));end);// End of text file reloFix// Beginning of text file Project Data// Sloup 2.2// © S. Weyer 1994-2001// fix Output to be async w/ callback??constant kSloup 	 := "Sloup";constant kSlurpee 	 := "Slurpee";constant kVersionNum := "2.2";constant kVersionInt := 22;constant kBetaVersion:= "i";DeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalConstant('kAll, true); // !!!f. not kIgnoreNativeKeyword or kBuild20); // currently, if native then add extra stuffconstant kNewEndPoint := kBuild20;	// !!!a//DefineGlobalConstant('kAddEncoding,	(NIL or language='Japanese or language='Chinese) and kNewEndPoint); // !!!aconstant kDefaultEncoding	:= 'sjis; //'|string.sjis|;DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if not kIgnoreNativeKeyword then $N) &	(if kBuild20 then "-2") &	(if language<>'english then $~ & Upcase(SPrintObject(language))[0])	// else if kAddEncoding then "~E"));DefineGlobalConstant('kVersion, kSloup && kVersionString);Print("slrp" & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then $N	else if kBuild20	then if language='English		then $2		else Upcase(SPrintObject(language))[0]	)	& ".pkg");Print(kVersion && DateNTime(Time()));Print(kAppSymbol);SetLocalizationFrame({ // use with LocObj(defaultStr, 'symbol)English: {descText:			kSloup && "transfers text and tab-delimiteddata between soups and a desktopterminal program.Shareware",waitSoupName:		"Waiting for soup name",waitEntrySpec:		"Waiting for entrySpec",waitEntries:		"Waiting for entries",AboutItem:			"About",HelpItem:			"Help",PrefsItem:			"Prefs",ChooseMsg:			"Choose",connectLabel:		"Connect",connected:			"connected",connecting:			"connecting",binding:			"binding",		// !!!adisconnectLabel:	"Disconnect",disconnected:		"Disconnected",disconnecting:		"disconnecting",instantiateEP:		"Instantiating",instantiateErr:		"Instantiate Error",connectErr:			"Connect Error",bindErr:			"Bind Error",	// !!!aacceptErr:			"Accept Error",DumpEntries:		"Dumping entries from",DumpPrefErr:		"dump prefs error",Pausing:			"Pausing ^0 secondsÉGet ready to receive",removingPackage:	"removing package",installingPackage:	"installing package",fixingPkg:			"fixing package",errorMsg:			"error",notSoupIndex:		"not a soupname/index",addingIndexes:		"adding indexes",paragraphMsg:		"paragraph",compileMsg:			"compile",evaluateMsg:		"evaluate",notFrameErr:		"not a frame",invalidEntrySpec:	"Entry spec invalid",sloupSetDone:		kSloup && "settings done",screenSmaller:		"Screen smaller than",eraseEntries:		"Erasing (^0) entries in ^1",allFolders:			"All",unfiledFolder:		"Unfiled",untitledLabel:		"untitled",		// e.g., Newtworks doc nameinspectLabel:		"Inspect",pasteLabel:			"Paste",statusLabel:		"Status",storeLabel:			"Store",		// e.g., card for dumping soup namessoupLabel:			"Soup",entryLabel:			"Entry",entriesLabel:		"Entries",indexLabel:			"Indexes",soundLabel:			"Sound",noItem:				"none",autoConnLabel:		"AutoConnect",refreshLabel:		"Refresh",encodingItem:		"Encoding",serial9600:			"9600",serial19200:		"19200",serial38400:		"38400",serial57600:		"57600",ADSPlabel:			"ADSP",ADSPslabel:			"ADSPs",serialMNP:			"MNP",slowIRitem:			"slowIR",			// i.e., old/SharpserialIRitem:		"serialIR",IrDAitem:			"IrDA",},// -----German: {	// Reinhold Schoeb <schoeba@str.daimler-benz.com>descText:	kSloup && "sendet Text und TAB-begrenzteDaten zwischen Soups und einemDesktop-Terminal-Programm.Shareware",//"Sloup transfers text and tab-delimited data between soups and a desktop terminal program. Shareware"waitSoupName:		"Warte auf Soup Name",					//"Waiting for soup name"waitEntrySpec:		"Warte auf Eintrag-Spez.",				//"Waiting for entrySpec"waitEntries:		"Warte auf Eintrge",					//"Waiting for entries"AboutItem:			"ber",									//"About"HelpItem:			"Help",	// ???							//"Help"PrefsItem:			"Einst.",								//"Prefs"ChooseMsg:			"Auswahl",								//"Choose"connectLabel:		"Verbinden",							//"Connect"connected:			"Verbunden",							//"connected"connecting:			"verbinde",								//"connecting"binding:			"verbinde",								//"binding"disconnectLabel:	"Unterbreche",							//"Disconnect"disconnected:		"Unterbrochen",							//"Disconnected"disconnecting:		"unterbreche",							//"disconnecting"instantiateEP:		"Sofortiger Schlu§",					//"Instantiating"instantiateErr:		"Sofortiger Fehler",					//"Instantiate Error"connectErr:			"Verbindungsfehler",					//"Connect Error"bindErr:			"Verbindungsfehler",					//"Bind Error"acceptErr:			"Accept Error",DumpEntries:		"Lese Eintrge von",					//"Dumping entries from"DumpPrefErr:		"Fehler: Lese Einst.",					//"dump prefs error"Pausing:			"Warte ^0 SekundenÉStarte Empfnger",	//"Pausing ^0 secondsÉGet ready to receive"removingPackage:	"lsche Package",						//"removing package"installingPackage:	"installiere Package",					//"installing package"fixingPkg:			"Fixiere Package",						//"fixing package",errorMsg:			"Fehler",								//"error"notSoupIndex:		"kein Soup-Name/Index",					//"not a soupname/index"addingIndexes:		"fge Indexe zu",						//"adding indexes"paragraphMsg:		"Absatz",								//"paragraph"compileMsg:			"bersetze",							//"compile"evaluateMsg:		"bewerte",								//"evaluate"notFrameErr:		"kein Rahmen",							//"not a frame"invalidEntrySpec:	"Eintrag-Spez. ungltig",				//"Entry spec invalid"sloupSetDone:		kSloup && "Einst. erfolgt",				//"Sloup settings done"screenSmaller:		"Bildschirm kleiner als",				//"Screen smaller than"eraseEntries:		"Lsche (^0) Eintrge in ^1",			//"Erasing (^0) entries in ^1"allFolders:			"Alle",									//"All"unfiledFolder:		"Nicht abgelegt",						//"Unfiled"untitledLabel:		"untitled",		// e.g., Newtworks doc nameinspectLabel:		"Kontr.",								//"Inspect"pasteLabel:			"Senden",								//"Paste" (was "Einfgen")statusLabel:		"Status",storeLabel:			"Store",		// e.g., card for dumping soup namessoupLabel:			"Soup",entryLabel:			"Eintrag",								//"Entry"entriesLabel:		"Eintrge",								//"Entries"indexLabel:			"Indexe",								//"Indexes"soundLabel:			"Ton",									//"Sound"noItem:				"ohne",									//"none"autoConnLabel:		"Autom. Verb.",							//"AutoConnect"refreshLabel:		"Refresh",encodingItem:		"Encoding",serial9600:			"9600",serial19200:		"19200",serial38400:		"38400",serial57600:		"57600",ADSPlabel:			"ADSP",ADSPslabel:			"ADSPs",serialMNP:			"MNP",slowIRitem:			"slowIR",			// i.e., old/SharpserialIRitem:		"serialIR",IrDAitem:			"IrDA",},// -----Japanese: {descText:			kSloup && "transfers text and tab-delimiteddata between soups and a desktopterminal program.Shareware",waitSoupName:		"Waiting for soup name",waitEntrySpec:		"Waiting for entrySpec",waitEntries:		"Waiting for entries",AboutItem:			"About",HelpItem:			"\u30D830EB30D7\u",	//"Help",PrefsItem:			"\u8A2D5B9A\u",		//"Prefs",ChooseMsg:			"\u9078629E\u",		//"Choose",connectLabel:		"\u63A57D9A5148\u",	//"Connect",  'connect to'?connected:			"\u63A57D9A3057307E3057305F\u",	//"connected",connecting:			"\u63A57D9A4E2D\u",	//"connecting",binding:			"\u305730663044307E3059\u",		//"binding" ?disconnectLabel:	"Disconnect",disconnected:		"Disconnected",disconnecting:		"\u520765AD4E2D\u",				//"disconnecting",instantiateEP:		"\u63A57D9A6E9650994E2D\u",		//"Instantiating",instantiateErr:		"\u63A57D9A6E965099306B593165573057307E3057305F\u",	//"Instantiate Error",connectErr:			"\u63A57D9A306B593165573057307E3057305F\u",	//"Connect Error",bindErr:			"Bind Error",acceptErr:			"Accept Error",DumpEntries:		"Dumping entries from",DumpPrefErr:		"dump prefs error",Pausing:			"Pausing ^0 secondsÉGet ready to receive",removingPackage:	"removing package",installingPackage:	"\u30A430F330B930C830FC30EB4E2D\u",		//"installing package",fixingPkg:			"fixing package",errorMsg:			"\u30A830E930FC\u",						//"error",notSoupIndex:		"not a soupname/index",addingIndexes:		"adding indexes",paragraphMsg:		"paragraph",compileMsg:			"\u30B330F330D130A430EB\u",				//"compile",evaluateMsg:		"\u8A554FA130A830E930FC\u",				//"evaluate",notFrameErr:		"not a frame",invalidEntrySpec:	"Entry spec invalid",sloupSetDone:		kSloup && "settings done",screenSmaller:		"\u753B9762304C5C0F30553059304E307E3059\u",	//"Screen smaller than",eraseEntries:		"Erasing (^0) entries in ^1",allFolders:			"All",unfiledFolder:		"Unfiled",untitledLabel:		"untitled",		// e.g., Newtworks doc nameinspectLabel:		"Inspect",pasteLabel:			"Paste",statusLabel:		"Status",storeLabel:			"Store",		// e.g., card for dumping soup namessoupLabel:			"Soup",entryLabel:			"Entry",entriesLabel:		"Entries",indexLabel:			"Indexes",soundLabel:			"Sound",noItem:				"\u71213057\u",		//"none",autoConnLabel:		"AutoConnect",refreshLabel:		"Refresh",encodingItem:		"\u30A830F330B330FC30C730A330F330B08A2D5B9A\u",	//"Encoding",serial9600:			"9600",serial19200:		"19200",serial38400:		"38400",serial57600:		"57600",ADSPlabel:			"ADSP",ADSPslabel:			"ADSPs",serialMNP:			"MNP",slowIRitem:			"slowIR",			// i.e., old/SharpserialIRitem:		"serialIR",IrDAitem:			"IrDA",},// -----Chinese: {descText:			kSloup && "transfers text and tab-delimiteddata between soups and a desktopterminal program.Shareware",waitSoupName:		"Waiting for soup name",waitEntrySpec:		"Waiting for entrySpec",waitEntries:		"Waiting for entries",AboutItem:			"\u95DC65BC\u",			//"About",HelpItem:			"\u8AAA660E\u",			//"Help",PrefsItem:			"\u8A2D5B9A\u",			//"Prefs",ChooseMsg:			"\u907864C7\u",			//"Choose",connectLabel:		"\u902363A581F3\u",		//"Connect",connected:			"\u5DF2902363A5\u",		//"connected",connecting:			"\u6B635728902363A5\u",	//"connecting",binding:			"binding",disconnectLabel:	"Disconnect",disconnected:		"Disconnected",disconnecting:		"\u89E39664902363A5\u",	//"disconnecting",instantiateEP:		"\u8D7759CB\u",			//"Instantiating",instantiateErr:		"\u8D7759CB932F8AA4\u",	//"Instantiate Error",connectErr:			"\u902363A5932F8AA4\u",	//"Connect Error",bindErr:			"Bind Error",acceptErr:			"Accept Error",DumpEntries:		"Dumping entries from",DumpPrefErr:		"dump prefs error",Pausing:			"Pausing ^0 secondsÉGet ready to receive",removingPackage:	"removing package",installingPackage:	"\u6B63572888DD8A2D0020005000610063006B006100670065\u",	//"installing package",fixingPkg:			"fixing package",errorMsg:			"\u932F8AA4\u",			//"error",notSoupIndex:		"not a soupname/index",addingIndexes:		"adding indexes",paragraphMsg:		"paragraph",compileMsg:			"\u7DE88B6F\u",	//"compile",evaluateMsg:		"evaluate",notFrameErr:		"not a frame",invalidEntrySpec:	"Entry spec invalid",sloupSetDone:		kSloup && "settings done",screenSmaller:		"Screen smaller than",eraseEntries:		"Erasing (^0) entries in ^1",allFolders:			"All",unfiledFolder:		"Unfiled",untitledLabel:		"untitled",		// e.g., Newtworks doc nameinspectLabel:		"Inspect",pasteLabel:			"Paste",statusLabel:		"Status",storeLabel:			"Store",		// e.g., card for dumping soup namessoupLabel:			"Soup",entryLabel:			"Entry",entriesLabel:		"Entries",indexLabel:			"Indexes",soundLabel:			"Sound",noItem:				"\u7121\u",		//"none",autoConnLabel:		"AutoConnect",refreshLabel:		"Refresh",encodingItem:		"\u7DE878BC65B95F0F\u",	//"Encoding",serial9600:			"9600",serial19200:		"19200",serial38400:		"38400",serial57600:		"57600",ADSPlabel:			"ADSP",ADSPslabel:			"ADSPs",serialMNP:			"MNP",slowIRitem:			"slowIR",			// i.e., old/SharpserialIRitem:		"serialIR",IrDAitem:			"IrDA",},});if kBuild20then begin	//DefineGlobalConstant('kRegisterCardSoupFunc, kRegisterCardSoupDeprecatedFunc);	//DefineGlobalConstant('kUnRegisterCardSoupFunc, kUnRegisterCardSoupDeprecatedFunc);	//DefineGlobalConstant('kGetUserConfigFunc, kGetUserConfigDeprecatedFunc);	DeclareGlobalFn('Query,2);	endelse begin	DeclareGlobalFn('RegPowerOff,2);	DeclareGlobalFn('UnRegPowerOff,1);	DeclareGlobalFn('GetGlobalFn,1);	DeclareGlobalFn('DefGlobalFn,2);	DeclareGlobalFn('XmitSoupChange,4);	DeclareGlobalFn('IsRichString,1);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('GetAppPrefs,2);	DeclareGlobalFn('RegUnionSoup,2);	DeclareGlobalFn('UnRegUnionSoup,2);	DeclareGlobalFn('AddDelayedCall,3);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('AddDelayedSend,4);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('LSearch,5);	DeclareGlobalFn('EntryRemoveFromSoupXmit,2);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('IsInteger,1);	DeclareGlobalFn('EntryChangeXmit, 2);	DeclareGlobalFn('GetPkgRef, 2);	DeclareGlobalFn('GetPackageNames, 1);	DeclareGlobalFn('SubstituteChars, 3);	end;DeclareGlobalFn('CharPos,3);DeclareGlobalFn('ClearVBOCache,1);DeclareGlobalFn('SoundList,0);DeclareGlobalFn('GetRegisteredSound,1);//if kAddEncoding thenDeclareGlobalFn('OpenPrefsTo, 1);DefineGlobalConstant('kMyRegCardSoup, func(soupName,soupIndexes,appSymbol,appObject)if kBuild20 or Functions.RegUnionSoup existsthen RegUnionSoup(appSymbol,		{name: 	 	soupName,		userName: 	soupName,		ownerApp:	kAppSymbol, // note: to match UnRegUnionSoup		userDescr:	soupName && appObject[1],		indexes: 	soupIndexes,		})else call kRegisterCardSoupFunc with (soupName,soupIndexes,appSymbol,appObject));DefineGlobalConstant('kMyUnRegCardSoup, func(soupName, delay)if kBuild20 or Functions.UnRegUnionSoup existsthen begin	UnRegUnionSoup(soupName,kAppSymbol);	if delay	then AddDelayedCall(GetGlobalFn('XmitSoupChange),       		[soupName, kAppSymbol, 'whatThe, NIL], delay);	endelse begin	call kUnregisterCardSoupFunc with (soupName);	if delay	then AddDelayedAction(Functions.BroadcastSoupChange,       		[soupName], delay)	end);DefineGlobalConstant('kDescText, LocObj("Sloup transfers text and tab-delimiteddata between soups and a desktopterminal program.Shareware", 'descText));DefineGlobalConstant('kAboutText, kDescText &&"\u00A9\u 1994-2001, S. Weyer.Steve Weyer17 Timber Knoll Dr.Washington Crossing, PA 18977-1052Internet: <A HREF=\"mailto:weyer@kagi.com\">weyer@kagi.com</A>AOL: SteveWeyer<A HREF=\"http://www.kagi.com/weyer/\">http://www.kagi.com/weyer/</A>");constant kDragRadius	:= 4;constant sysSoupName	:= ROM_systemsoupname;constant noteSoupName	:= ROM_paperrollsoupname;constant kPaperRollSym	:= 'paperRoll;constant cardSoupName	:= ROM_cardfilesoupname;constant kPackage		:= "Package";constant endOfPara		:= "-----";constant noteHeight		:= 265;//constant noteWidth	:= 226;constant noteLeft		:= 10;constant noteTop		:= 2;constant tab			:= "\t";constant cr				:= "\n";constant unicodeStart	:= "\\u";constant eString		:= "";constant lf				:= "\u000A";constant kClassString	:= "class:string";constant kHex			:= "0123456789ABCDEF";DefineGlobalConstant('kDefaultIndex, {type: 'index});DefineGlobalConstant('zeroChar, Ord($0));DefineGlobalConstant('crlf,		unicodeCR&unicodeLF);constant kADSPitem  	:= 4;constant kMNPitem		:= 5;	// !!!aconstant kSlowIRitem	:= 6;	// !!!aconstant kSerialIRitem	:= 7;	// !!!aconstant kIrDAitem  	:= 8;	// !!!aconstant k115KItem		:= 9;	// !!!iconstant k230KItem		:=10;	// !!!i// generate via call kGetCommPortInfoFunc with () ???// offer control panel like in ClarisTerm??DefineGlobalConstant('kConnLabels, [	// !!!a// these must correspond to bpsOptions (and see constants above)LocObj("9600", 'serial9600),LocObj("19200", 'serial19200),LocObj("38400", 'serial38400),LocObj("57600", 'serial57600),LocObj("ADSP", 'ADSPlabel),LocObj("MNP", 'serialMNP),LocObj("slowIR", 'slowIRitem),LocObj("serialIR", 'serialIRitem),LocObj("IrDA", 'IrDAitem),"115200",	// LocObj???		// !!!i. see bpsOptions, getConfigOptions, kItemLen"230400",//modem, ...?]);DefineGlobalConstant('kItemLen,	(if kBuild20 then k230KItem else if kAll then kSlowIRitem else 0) + 1);SetLength(kConnLabels, kItemLen);DefineGlobalConstant('kWaitingSoup,		LocObj("Waiting for soup name", 'waitSoupName));DefineGlobalConstant('kWaitingEntrySpec,LocObj("Waiting for entrySpec", 'waitEntrySpec));DefineGlobalConstant('kWaitingEntries,	LocObj("Waiting for entries",	'waitEntries));constant kBinaryStart	:= "!";constant kDecimal		:= ".";constant kColon			:= ":";constant kPara			:= "para";constant kBits			:= "bits";constant kBitmap		:= "bitmap";constant kPicture		:= "picture";constant kResource		:= "resource";constant kSamples		:= "samples";constant kSound			:= "sound";constant kBinaryPrefix	:= "binary:";constant kLongStr		:= "longString";DefineGlobalConstant('kExcl, kBinaryStart);DefineGlobalConstant('kBinaryTypes, [kBitmap, kBits, kPicture, kSamples, kSound, kResource]);constant kBitmapHeadLen	:= 16;constant kBYE			:= "BYE!";constant kReplace		:= "REPLACE!";constant kDump			:= "DUMP!";constant kErase			:= "ERASE!";constant kEval			:= "EVAL!";constant kAbortDelay	:= 2000;constant kOutputDelay	:= 6;	// 1/10 sec. for IR, ADSP?DefineGlobalConstant('kConnect,			LocObj("Connect",		'connectLabel));DefineGlobalConstant('kConnected,		LocObj("connected",		'connected));DefineGlobalConstant('kDisconnect,		LocObj("Disconnect",	'disconnectLabel));DefineGlobalConstant('kDisconnected,	LocObj("Disconnected",	'disconnected));DefineGlobalConstant('kDisconnecting,	LocObj("disconnecting",	'disconnecting));DefineGlobalConstant('kError,			LocObj("error",			'errorMsg) & $:);DefineGlobalConstant('kerrSound, 	ROM_plinkbeep);DefineGlobalConstant('keraseSound, 	ROM_poof);DefineGlobalConstant('kevalSound, 	ROM_plunk);DefineGlobalConstant('kClear, 		unicodeESC);	// $\1B. Clear key (same as ESC?)DefineGlobalConstant('kEvalChar,	unicodeSUB);	// $1A (ctrl-Z)DefineGlobalConstant('kEnter, 		unicodeETX);	// $\03.  Enter keyDefineGlobalConstant('kClose, 		unicodeETB);	// $\17. close window (ctrl-W?) ***DefineGlobalConstant('kScrollUp,   	unicodeRS);		// $\1E  scroll up   (ctrl-^)DefineGlobalConstant('kScrollDown, 	unicodeUS);		// $\1F. scroll down (ctrl-v)constant kStoreID := "storeID";	// !!!hconstant kInspHeight	:=  42;	// was 40,36. top of statusLabelconstant kAppHeight		:= 172; // full heightconstant kInspWidth		:=  58;	// was 56. left edge of sloupTitleconstant kAppWidth		:= 208;constant kRegistrationPackage := '|Register:FlaSheridn|;constant kSharewareFee := 10;DefineGlobalConstant('kRegFrame, {	package: kAppSymbol, 	price: 	 kSharewareFee,	platform: 'Newton, 	Version: kVersionString,	});DefineGlobalConstant('kMySPrintObject, func(s)if (if kBuild20 then IsString(s) else isInstance(s,'string))then Clone(s) // fix >1K bugelse SPrintObject(s));DefineGlobalConstant('kOutputStr, func(strm, str)if strmthen strm:Output(str, nil)else Write(str));DefineGlobalConstant('kLabelEqual, func(elabel1, elabel2)	// elabel1=entrySpec.labels, elabel2=entry.labelselabel1 = elabel2 or(isArray(elabel2) and	// SuperNotepad	if elabel1	then SetContains(elabel2, elabel1)	else Length(elabel2)=0));if not IsGlobalConstant('kVBOFlush) thenDefineGlobalConstant('kVBOFlush, 24*1024);	// every 24K or so? ( < 32K?)DefineGlobalConstant('kNewtworksSoupName,	"NewtWorks");DefineGlobalConstant('kNewtworksSym,		'Newtworks);// same as kNewVBO in Newt's CapeDefineGlobalConstant('kNewVBO, func(store, cl, dlen)	// the recommended initializationbegin	gc();	local data := if not IsInteger(dlen) then dlen;		// string or binary obj	local vbo :=		(if store then store else GetDefaultStore()):NewCompressedVBO(			if cl then cl else 'string,			// cl == binary			if data then Length(data) else dlen,// length of string or binary or #			kTextCompander, 					// kBitmapCompander unreliable for bin?			nil);/*	if data	then begin		BinaryMunger(vbo, 0, nil, data, 0, nil);		if Length(data) > 2		then ClearVBOCache(vbo);		end;*/	vbo;end);constant kRejectChars := "\u2206\u"; // graphic indicatorDefineGlobalConstant('kFixCR, func(ep, str)	// !!!g. unicode(encoding) safeif kBuild20 and isFrame(ep) and ep.NTEncodingthen begin	local i := 0;	while (i := CharPos(str, unicodeCR, i))	do begin		StrMunger(str,i,1, crlf,0,2);		i := i+2;		end;	endelse StrReplace(str, cr, crlf, nil));DefineGlobalConstant('kOutputNewtWorksRange, func(textView, range, commEndPt) // dumpNoteStringbegin // QA: Extracting All Text from a ProtoTXView Object	constant kChunkSize := 0x1000; // 4K    local INT i, start := if range then range.first else 0, nextFlush := kVBOFlush, slen := 0;    local INT last := if range then range.last else textView:GetCountCharacters(); 	local cstr, str;  	if last-start < kChunkSize	// !!!c. 'small' range (don't bother with VBO) 	then begin 		cstr := StringFilter( // strip out graphics characters					textView:GetRangeData({first: start, last: last}, 'text),					kRejectChars, 'rejectAll) & unicodeCR; 		if commEndPt 		then begin 			call kFixCR with (commEndPt, cstr);	// !!!g. StrReplace(cstr, cr, crlf, nil) 			call kOutputStr with (commEndPt, cstr); 			end; 		return cstr; 		end;     if not commEndPt    then str := call kNewVBO with (nil, nil, ""); // !!!c	for i := start to last by kChunkSize    do begin		cstr := StringFilter( // strip out graphics characters				textView:GetRangeData(					{first: i, 					last: min(last, i + kChunkSize),					}, 'text),				kRejectChars, 'rejectAll);		if commEndPt		then begin			call kFixCR with (commEndPt, cstr); 	// !!!g			call kOutputStr with (commEndPt, cstr);			end		else begin // !!!c			StrMunger(str, slen, 0,	cstr, 0, nil);			slen := slen + StrLen(cstr);			if (slen*2) >= nextFlush			then begin				ClearVBOCache(str);				nextFlush := nextFlush + kVBOFlush;				end;			end;		end;	// !!!c. add final cr	if commEndPt	then call kOutputStr with (commEndPt, crlf)	else begin		StrMunger(str,slen,0, crlf,0,1);		ClearVBOCache(str);		str;		end;end);DefineGlobalConstant('kDummyTx, {		// dumpNoteString, kNewtWorksNewDoc	_proto: if kBuild20 then protoTxView,	viewBounds: SetBounds(0,0,0,0),	viewFlags: 0,	ReorientToScreen: if kBuild20 then ROM_DefRotateFunc,	viewSetupFormScript: func()	begin		inherited:?viewSetupFormScript();		:SetGeometry(nil, 0, 0, SetBounds(32, 32, 32, 32));	// margins		:SetStore(GetDefaultStore())						// store	end,});DefineGlobalConstant('kNewtWorksNewDoc, func(title, obj, margins, store, label)	// addNewEntryif GetRoot().(kNewtworksSym)then begin	if not margins	then margins := SetBounds(32, 32, 32, 32);	if not store	then store := GetDefaultStore();	// use a txView to properly create the SaveData info	local dummy := BuildContext(kDummyTx);	dummy:Open();	dummy:Replace({first: 0, last: 0}, obj, nil); 	local saveData := dummy:Externalize();	local summary := SubstituteChars(	// no graphics added, no need to filter		dummy:GetRangeData({first: 0, last: min(dummy:GetCountCharacters(), 80)}, 'text), cr, " "); // !!!e	dummy:Close(); 	GetRoot().(kNewtworksSym):AdoptEntryFromStationery({	// add the data to Newtworks		title: Clone(title),		saveData: saveData,		hiliteRange: {first: 0, last: 0},		margins: margins,		labels: label,		summary: summary,	// !!!e		},		'paper,		store);	end);// assume readonly (otherwise, avoid cloning)?// assume each element of path is frame or array (or test based on path1 sym/int)?DefineGlobalConstant('kSetClone, func(obj, ARRAY path, val)	// !!!abegin	if isReadonly(obj)	then obj := Clone(obj);	local nobj := obj;	local INT i, last := Length(path)-1;	foreach i,path1 in path	do nobj := nobj.(path1) := if i=last then val else Clone(nobj.(path1));	obj;end);constant kNewtSymbol := '|NewtDevEnv:TKnollSys|;constant kSlotSymbol	:= 'views;constant kViewSymbol	:= 'Sloup;constant kInstalled	:= 'installed;//constant kNewtsCapeSymbol := '|NewtsCape:NewtsCape|;	// !!!d. defined in protoAboutText//INSTALL & REMOVE scriptsInstallScript := func(partFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	if not gData	then begin		gData := EnsureInternal(				{constants: {}, libraries: {}, protos: {},				tools: {}, views: {}, installed: {}, });		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(EnsureInternal(kNewtSymbol)) := gData		else DefGlobalVar(EnsureInternal(kNewtSymbol), gData);		end;	gData.(kSlotSymbol).(EnsureInternal(kViewSymbol))	:= kAppSymbol;	gData.(kInstalled).(EnsureInternal(kAppSymbol))		:= kVersion;//if kDebugOn then AddDeferredCall(func() GetRoot().(kAppSymbol):?Open(), nil);end;RemoveScript := func(partFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	RemoveSlot(gData.(kSlotSymbol), kViewSymbol);	RemoveSlot(gData.(kInstalled), 	kAppSymbol);end;/*GetRoot().|Sloup:TKnollSys|:addFile("text/plain", "foo.dmp","Notes{labels: nil, class: 'checkList}DUMP!", nil)Package{packageName: \"StewPot:KAUi\", packageEntry: \"binary:packageEntry\"}DUMP!*/// End of text file Project Data// Beginning of file protoAboutText// Before Script for _v81_0beginconstant kNewtsCapeSymbol	:= '|Newtscape:Newtscape|;DefConst('kFixupHREFtext, func(template) // used in instance's afterScriptbegin	// extract&remove HREF info, emphasize URLs with underline	// this version assumes syntactically correct URLs (no extra/missing chars)	// <A HREF="href">label</A>	// e.g., <A HREF="http://">home page</A>	// e.g., <A HREF="mailto:...">email addr</A>	local ARRAY styles := [], hrefs := [];	local text := template.text, href;	local regfont := template.viewFont, urlfont;	if isFrame(regfont)	then begin		urlfont := Clone(regfont);		urlfont.face := BOR(urlfont.face, kFaceUnderline);		end	else urlfont := BOR(regfont,tsUnderLine);	local spos, qpos, epos := 0;	while spos := StrPos(text, "<A HREF", epos)	do begin		// non-empty regular text before <A...		if spos > epos		then begin			AddArraySlot(styles, spos-epos);			AddArraySlot(styles, regfont);			end;		// extract href string: "http:..."		qpos := StrPos(text,"\"",spos)+1;		epos := StrPos(text,"\"",qpos);		href := SubStr(text,qpos,epos-qpos);		// remove HTML before label: <A HREF="...">		epos := StrPos(text, ">", epos);		StrMunger(text,spos,epos+1-spos, nil,0,nil);		// remove HTML after label: </A>		epos := StrPos(text,"</A>",spos);		StrMunger(text,epos,4, nil,0,nil);		// highlight label		AddArraySlot(styles, epos-spos);		AddArraySlot(styles, urlfont);		// save href (for viewClickScript)		AddArraySlot(hrefs, [href, spos, epos]);		end;	// any regular text at end?	if epos < StrLen(text)	then begin		AddArraySlot(styles,StrLen(text)-epos);		AddArraySlot(styles, regfont);		end;if kDebugOnthen begin	Print("about text:");	Print(text);	Print("about hrefs:");	Print(hrefs);	end;	template.styles := styles;	template.hrefs := hrefs;	template.text := text;	RemoveSlot(template,'viewFont);end);end_v81_0 :=    {viewBounds: {left: 1, top: 1, right: -1, bottom: -15},     viewFlags: 513,     viewFont:       simpleFont10 // note: this will be replaced by styles. coord with linespacing       ,     viewFormat: 257,     viewLineSpacing: 12,     text: "",     viewClickScript:       func(unit)       begin       /*       	this finds the HREF that's clicked on (precomputed in afterScript)       	highlights it       	dispatches via urlCop or Newt's Cape       	unhighlights       */              	local hrefentry, href, options := {}, spos, epos, app;       	local INT cpos := :MyPointToCharOffset(GetPoint(firstX,unit), GetPoint(firstY,unit));       	local ttitle := GetVariable(self, 'title);	// from app       	if not isInstance(ttitle, 'string)       	then ttitle := "untitled";              //Print(cpos);       //if cpos >=0 then Print(text[cpos]);              	if cpos >= 0       	then foreach hrefentry in hrefs // e.g., [["http:...", 10,20],...]       		do if (spos := hrefentry[1]) <= cpos and       				cpos <= (epos := hrefentry[2])       		then begin       			:SetHilite(spos, epos, true);       			href := hrefEntry[0];              			// dispatch using urlCop if installed (and url type is registered)       			if (app := GetRoot().urlCop:?PreferredApp(href, 'getURL, {}))       				and app <> kNewtsCapeSymbol       			then GetRoot().urlCop:getURL(href,options) // .(app): ?              			else if GetRoot().(kNewtsCapeSymbol) // Newt's Cape installed?       			then begin       				if BeginsWith(href,"mailto:")       				then begin       					options.subject := ttitle;        					options.name 	:= SubStr(text,spos,epos-spos);       					options.body 	:= "I really like" && ttitle;       					end       				else options.noStatus := not kDebugOn; // hidden for end users       				GetRoot().(kNewtsCapeSymbol):getURL(href,options);       				end       			else if kDebugOn       			then Print(href);              			break :SetHilite(cpos,cpos,true); // would be nice to get rid of the caret too       			end;       	TRUE; // handled click       end,     viewJustify: 240,     MyPointToCharOffset:       func(x,y)        if kBuild20 or HasVariable(self, 'PointToCharOffset)       then :PointToCharOffset(x,y)              else begin // 1.x definition       	local gb := :GlobalBox();       	x := x - gb.left;       	y := y - gb.top;       	//Print([x,y]);              	local spos, epos := -1;       	local INT i, linenum := y div viewLineSpacing;       	if linenum < 0 then return -1;              	// find the line       	// assume all cr-delimited with no wrapping       	for i:=0 to linenum       	do if epos       		then begin       			spos := epos+1;       			epos := StrPos(text,"\n",spos);       			end       		else return -1;              	local newstr := {       		viewFont: styles[1],       		msg: Functions.StrTruncate}:msg(SubStr(text,spos,epos), x);              	spos + StrLen(newstr)-1; // É on end       	end,     viewClass: 81 /* clParagraphView */    };// After Script for _v81_0thisView := _v81_0;begin// for NewtthisView.viewSetupFormScript := func()begin	if not IsReadOnly(self._proto) and StrPos(text,"<A HREF",0)	then call kFixupHREFtext with (self._proto);	//inherited:?viewSetupFormScript();end;endconstant |layout_protoAboutText| := _v81_0;// End of file protoAboutText// Beginning of file aboutLayout2_v180_0 :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewJustify: 240,     _proto: @180 /* protoFloatNGo */    };_v180_0_v0_0 := {_proto: _v81_0};AddStepForm(_v180_0, _v180_0_v0_0);// After Script for _v180_0_v0_0thisView := _v180_0_v0_0;begin	thisView.text := kAboutText;	call kFixupHREFtext with (thisView);endconstant |layout_aboutLayout2| := _v180_0;// End of file aboutLayout2// Beginning of file protoCheckPref_v164_0 :=    {viewBounds: {left: 16, top: 16, right: 120, bottom: 32},     valueChanged:       func()       :setPreference(prefSym,viewValue),     viewSetupFormScript:       func()       begin       	viewValue := prefsCurrent.(prefSym);       	inherited:?viewSetupFormScript();       end,     _proto: @164 /* protoCheckBox */    };constant |layout_protoCheckPref| := _v164_0;// End of file protoCheckPref// Beginning of file myProtoInfoButton// Before Script for _v76_0DefConst('kFixupInfoItems, func(template)begin	local items := template.AppInfoItems := [];	if HasSlot(template, 'DoInfoAbout)	then AddArraySlot(items, LocObj("About", 'AboutItem));	if HasSlot(template, 'DoInfoHelp)	then AddArraySlot(items, LocObj("Help", 'HelpItem));	if HasSlot(template, 'DoInfoPrefs)	then AddArraySlot(items, LocObj("Prefs", 'PrefsItem));	local auxItems := template:?GenInfoAuxItems();	if isArray(auxItems) and Length(auxItems) > 0		and HasSlot(template,'DoInfoAux)	then begin		AddArraySlot(items, 'pickSeparator);		template.AuxOffset := Length(items);		ArrayMunger(			items, Length(items), 0,			auxItems, 0, nil);		end;end)_v76_0 :=    {icon: GetPictAsBits("info icon", nil),     viewBounds: {left: 6, top: 0, right: 19, bottom: 13},     viewFlags: 513,     viewFormat: 67109457,     viewJustify: 17446,     viewClickScript:       func(unit)       if :TrackHilite(unit)       then if kBuild20 or HasVariable(:Parent(),'PopupMenu)       	then :PopupMenu(AppInfoItems, {left: 0, top: 0})       	else begin       		local l := :LocalBox();       		DoPopUp(AppInfoItems, l.right+3, l.top, self);       		end,     pickActionScript:       func(index)       begin       	// MUST do this       	:Hilite(nil);              	if auxOffset and index >= auxOffset       	then :DoInfoAux(:GenInfoAuxItems(), index - auxOffset)       	else Perform(self, '{       		About:	DoInfoAbout,       		Help:	DoInfoHelp,       		Prefs:	DoInfoPrefs}.(Intern(AppInfoItems[index])), []);       end,     pickCancelledScript: func() :Hilite(nil),     AppInfoItems:       [] // set in afterScript       ,     auxOffset: nil,     viewClass: 76 /* clPictureView */    };// After Script for _v76_0thisView := _v76_0;/* // for NewtthisView.viewSetupFormScript := func()begin	if not IsReadOnly(self._proto)	then call kFixupInfoItems with (self._proto);	//inherited:?viewSetupFormScript();end*/constant |layout_myProtoInfoButton| := _v76_0;// End of file myProtoInfoButton// Beginning of file SloupBaseView.tsloupBaseView :=    {versionString: kVersionString,     myStrMunger:       func(str1, start1, count1, str2, start2, count2)       begin       	StrMunger(       		str1, if start1 then start1 else StrLen(str1), count1,	// start=nil -> end       		str2, start2, count2);       	if kBuild20 and Length(str1) > nextFlush       	then begin       		if IsVBO(str1)       		then ClearVBOCache(str1);       		nextFlush := nextFlush + kVBOFlush;       		end;       end,     registerButton: nil,     initConfig:       func(cmd)       begin       	:epDisconnect();       	sloupType := cmd;	// !!!a. save              	// !!!a       	configOptions :=       		if kAll and (cmd = kADSPitem) and prefsCurrent.connect       		then :getConfigOptions(cmd, prefsCurrent.host, prefsCurrent.zone, sloup)       		else :getConfigOptions(cmd, nil, nil, sloup);       end,     newEntry: nil,     viewSetupDoneScript:       func()       begin       	self.sloup := self;       	local root := GetRoot();       	if not root.(kNewtSymbol)       	then newtButton:hide();       	if not root.(kRegistrationPackage)       	then registerButton:?hide();       	sloupedGauge:close();       	targetSoup := commEndPt := NIL;       	if kBuild20       	then self.nextFlush := kVBOFlush;       	:initConfig(if kAll then min(prefsCurrent.bps, Length(bpsOptions)-1) else 0); // !!!a              	if kBuild20 or nos20       	then RegPowerOff(kAppSymbol, func(what,why) sloup:powerOffScript(what));       	else begin       		AddPowerOffHandler(self);       		root.ExtrasDrawer:?close();       		end;              	if prefsCurrent.connect       	then :epConnect();       end,     sloupType: nil,     dumpEntries:       func(dumpStr)       if targetSoup       then begin       	//if kAll and IR	// !!!a       	//then commEndPt:SetInputSpec(nil);              	:setStatus(LocObj("Dumping entries from", 'DumpEntries) && targetSoupName);       	local spos := if kBuild20 then CharPos(dumpStr,$!,0)+1 else StrPos(dumpStr,kExcl,0)+1, slen := StrLen(dumpStr), dumpPrefs := {};       	if spos < slen-1       	then try dumpPrefs := call Compile(Substr(dumpStr,spos,slen-spos)) with ()             	onexception |evt.ex|       			do :print(LocObj("dump prefs error", 'DumpPrefErr));              //{delay: , printFunction: , fieldDelimiter: , recordDelimiter:, soupDelimiter: ,}       	       	//local notes := StrEqual(targetSoupName, noteSoupName) or (kBuild20 and StrEqual(targetSoupName, kNewtworksSoupName));       	local sfun, secs, fieldSep, recordSep, soupSep;              	if (secs := dumpPrefs.delay) //or (if kAll and IR then secs := 5)       	then begin       		:setEntry(ParamStr(LocObj("Pausing ^0 secondsÉGet ready to receive", 'Pausing), [SPrintObject(secs)]));       		RefreshViews();       	  	Sleep(secs*60);       		end;              	local nameSep := dumpPrefs.nameDelimiter;	// !!!i              	if not (sfun := dumpPrefs.printFunction) or sfun = Functions.SPrintObject       	then sfun := kMySPrintObject;              	if not (fieldSep := dumpPrefs.fieldDelimiter)       	then fieldSep := if notes then crlf&crlf else tab;              	if not (recordSep := dumpPrefs.recordDelimiter)       	then recordSep := if notes then crlf&endOfPara else "";       	if not dumpPrefs.noAddDelimCR       	then recordSep := recordSep & crlf;              	if not (soupSep := dumpPrefs.soupDelimiter)       	then soupSep := kBye;       	if not dumpPrefs.noAddDelimCR       	then soupSep := soupSep & crlf;              	local elabel := entrySpec.labels, entry;       	local querySpec :=       		if not HasSlot(entrySpec,'labels) or       			elabel = '_all or elabel = 'symbol       		then if kBuild20 then nil else kDefaultIndex	// all       		else {       			type: 'index,       			validTest: func(e)       				call kLabelEqual with (elabel, e.labels),       			};       	local cursor :=       		if kBuild20       		then if StrEqual(targetSoupName, kPackage)       			then { // fake cursor for single package       				_parent: self,       				entry: func()       					if Length(entrySpec) > 0       					then begin       						local store, pkg;       						foreach store in GetStores()       						do if pkg := GetPkgRef(entrySpec.packageName, store)       						then begin       							:SetStatus(LocObj("fixing package", 'fixingPkg)); RefreshViews();       							pkg := {       								nextFlush:	kVBOFlush,       								reloFix: 	kReloFix,       								reloFixObj: kReloFixObj,       								}:reloFix(pkg, true);	// !!!i       							return if pkg then {packageName: entrySpec.packageName, packageEntry: pkg};       							end;       						NIL;       						end,       				//next: func() NIL,       				countEntries: func() 1,	// !!!d       				}       			else targetSoup:Query(querySpec)	// !!!d       		// 1.x       		else if not StrEqual(targetSoupName, kPackage)       		then Query(targetSoup, querySpec);		// !!!d              	if dumpPrefs.count	// !!!d       	then begin       		local len;       		if kBuild20       		then len := cursor:countEntries()       		else begin       			len := 0;       			entry := cursor:entry();       			while entry       			do begin       				len := len+1;       				entry := nil;       				entry := cursor:next();       				end;       			cursor:reset();       			end;       		sloupSpec := {_proto: sloupSpec, totalRecords: len};       		call kOutputStr with (commEndPt, "Count:" && len & crlf);       		sloupedGauge:?open();       		sloupSpec := sloupSpec._proto;       		end;              	entry := cursor:?entry();              	if Length(entrySpec)=0       	then if isFrame(targetSoup) and entry       		then :print(entrySpec := :dumpEntrySpec(entry))       		else if kBuild20 and StrEqual(targetSoupName, kPackage)       		then begin       			local pkg, store;       			foreach store in GetStores()       			do  foreach pkg in GetPackageNames(store)       				do begin       					call kOutputStr with (commEndPt, pkg & crlf);       					:setNumEntries(numEntries+1);		// !!!a       					end;       			return call kOutputStr with (commEndPt, soupSep);       			end;              	local msg :=       		if notes       		then 'dumpNoteString       		else 'dumpEntryString;       //Print(entryspec);       	while entry       	do begin       		if // !!!d. (all or call kLabelEqual with (elabel, entry.labels)) and       			Perform(self, msg, [entrySpec, entry, sfun, fieldSep, true, nameSep])       		then begin       			:setNumEntries(numEntries+1);       			:setStatus(eString);       			call kOutputStr with (commEndPt, recordSep); // write out final delim(crlf) & flush       			if prefsCurrent.refresh       			then RefreshViews();       			end;       		entry := NIL; // in case entries are very large       		entry := cursor:?next();       		end;       	call kOutputStr with (commEndPt, soupSep);       	end,     sharewareFee: kSharewareFee,     setPreference:       func(prefSym,val)       begin       	prefsEntry.(prefSym) := prefsCurrent.(prefSym) := val;       	if kBuild20       	then EntryChangeXmit(prefsEntry, nil)       	else EntryChange(prefsEntry);       end,     viewFormat: 83952897,     dumpEntryString:       func(espec, entry, sfun, fieldSep, first, nameSep) // basically the inverse of buildEntry       // this version writes out intermediate results rather than concatenating as a (big) line       begin       	local field, pclass, path, pvalue, evalue, eval1, pval1;       	foreach path,pvalue in espec       	do begin       		pclass := PrimClassOf(pvalue);       		evalue := entry.(path);       		field := if pClass = 'array and Length(pvalue) = 1 and        					isArray(evalue) and Length(evalue) > 1       					//and not isArray(pval1 := pvalue[0]) // ok if string or frame       				then begin // handle variable length array       					:dumpEntryString(Array(Length(evalue), pvalue[0]), evalue, sfun, fieldSep, first, nameSep)       					/*foreach eval1 in evalue       					do begin       						if not eval1 then if isFrame(pval1) then eval1 := {};       						if eval1       						then :dumpEntryString(pval1, eval1, sfun, fieldSep, first, nameSep);       						first := NIL;       						end;       					NIL;*/       					end              				else if pClass='frame or pClass='array       				then :dumpEntryString(pvalue,       								if evalue then evalue       								else if pclass='frame then {}       								else Array(Length(pvalue),NIL),       								sfun, fieldSep, first, nameSep)              				else if not evalue       				then ""       				else if (if kBuild20 then IsString(pvalue) else isInstance(pvalue, 'string))       				then if StrEqual(pvalue, kPara)       					then evalue.text              					else if StrEqual(pvalue, "dateTime")       					then DateNTime(evalue)              					else if BeginsWith(pvalue, "dateTimeSpecs:")       					then begin       						local i, result, val;       						local ARRAY dateFuncs := '[LongDateStr,ShortDateStr,TimeStr];       						local vals :=       							try call compile (SubStr(pvalue,(if kBuild20 then CharPos(pvalue,$:,0) else StrPos(pvalue,":",0))+1,nil)) with ()       							onexception |evt.ex| do NIL;       						if isArray(vals)       						then foreach i,val in vals       						do if val       						then begin       							val := call Functions.(dateFuncs[i]) with (evalue, val);       							result := if result then result && val else val;       							end;       						result;       						end              					else if BeginsWith(pvalue, "date")       					then ShortDateStr(evalue,112220) //shortDateStrSpec              					else if StrEqual(pvalue, "boolean")       					then if evalue then "true" else "nil"              					else if StrEqual(pvalue, kBits)       							or StrEqual(pvalue,kBitmap) // for compat       					then if isBinary(evalue)       						then :BitsToString(evalue, if ClassOf(evalue)='bits then 16 else 0)       						else :BitsToString(evalue.bits,16)              					else if StrEqual(pvalue, kPicture)       							or StrEqual(pvalue, kResource)       							or BeginsWith(pvalue, kBinaryPrefix)       					then :BitsToString(evalue, 0)              					else if StrEqual(pvalue, kSamples)       							or StrEqual(pvalue,kSound)       					then :BitsToString(evalue.samples, 0)              					else if StrEqual(pvalue, kClassString)       					then ClassOf(evalue) & $: & evalue              					//else if StrEqual(pvalue, kStoreID)       					//then NumberStr(entry:GetStore():GetSignature())	// !!!h ??              					else call sfun with (evalue)       				else call sfun with (evalue);              		if (if kBuild20 then IsString(field) else isInstance(field,'string))       		then begin       			if first and prefsCurrent.refresh       			then :setEntry(field); // display 1st field       			if nameSep then field := path & nameSep & field;	// !!!i       			call kOutputStr with (commEndPt, field & fieldSep);       			end;       		first := NIL;       		end;       	TRUE; // final cr&flush in dumpEntries       end,     epDisconnect:       func()       begin       	if commEndPt       	then commEndPt := :closeEndpoint(commEndPt, sloup); // !!!a              	connPicker:?updateText(kDisconnected);	// !!!f       	/*if connButton       	then begin       		SetValue(connButton, 'text, kConnect);       		connStatus:?update();       		end;*/              	if isFrame(targetSoup)       	then call kMyUnRegCardSoup with (targetSoupName, kAbortDelay);       end,     bpsOptions:       /*       on MP100:       ADSP  hangs after sending ~5 lines       MNP   doesn't connect       slowIR?              on MP2K       slowIR -- hangs on other Newton on 2nd DUMP!       IrDA?       */                     [	// same length as bpsPicker.labelCommands (trimmed in afterScript)              // ----- serial (2.x) "9600" ----- [9600 already set]              if kNewEndPoint       then {       label:	kCMOSerialHWChipLoc,       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data:	{       	argList: [       		kHWLocExternalSerial, // see serial IR. ? kHWLocPCMCIASlot1       		0,	],       	typeList: ['struct,       		['array, 'char, 4],       		'ulong,	],       	},       },	              // ----- serial 19200, 38400, 57600 -----              k19200bps,              k38400bps,              k57600bps,              // ----- ADSP -----              if kNewEndpoint       then [       {label:	kCMSAppleTalkID,       type:	'service,       opCode:	opSetRequired,       },       {label:	kCMSAppleTalkID,        type:	'option,        opCode:	opSetRequired,       data:  {       	arglist: ["adsp"],       	typelist:['struct,       		['array, 'char, 4]       		],       	},       },       {label:	kCMOEndpointName,       type:	'option,       opCode:	opSetRequired,       data:	{       	arglist:  [kADSPEndpoint],       	typelist: ['struct,       		['array, 'char, 0],	//?? [11, 13, 0]       		],       	},       },       {label:	kCMOAppleTalkBuffer,       type:	'option,       opCode:	opSetRequired,       data:	{       	arglist:		[       		kSndBuffer,       		511,       		],       	typeList: ['struct,       		'ulong,       		'ulong,       		],       	},       },       {label:	kCMOAppleTalkBuffer,       type:	'option,       opCode:	opSetRequired,       data:	{       	arglist: [       		kRcvBuffer,       		511,		],       	typeList: ['struct,       		'ulong,       		'ulong,       		],       	},       },       {label:	kCMOAppleTalkBuffer,       type:	'option,       opCode:	opSetRequired,       data:	{       	arglist: [       		kAtnBuffer,       		0,       		],       	typeList: ['struct,       		'ulong,       		'ulong,       		],       	},       },       ]              else if kAll       then [       {label:	kCMSAppleTalkID,       type:	'service,       opCode:	opSetRequired,       },       {label:	kCMSAppleTalkID,        type:	'option,        opCode:	opSetRequired,       data:	kCMOAppleTalkADSP,       },       {label:	kCMOEndpointName,       type:	'option,       opCode:	opSetRequired,       data:	kADSPEndpoint,       },       ],              // ----- MNP -----              if kAll       then [       {label:	kCMSMNPID,       type:	'service,       result:	nil,       opCode: opSetRequired,       },       {label:	kCMOMNPDataRate,       type:	'option,       result:	nil,       opCode:	opSetRequired,       form:	'number,       data:	k57600bps,       },       {label:	kCMOSerialIOParms,       type:	'option,       result:	nil,       opCode:	opSetRequired,       form:	'template,       data:	if kNewEndpoint       	then {       		arglist: [       			k1StopBits,       			kNoParity,       			k8DataBits,       			k57600bps,       			],       		typelist: ['struct,       			'long,       			'long,       			'long,       			'long,       			],       		}       	else {       		bps: k57600bps, dataBits: k8DataBits,       		stopBits: k1StopBits, parity: kNoParity,       		},       },       {label:	kCMOMNPCompression,       type: 	'option,       result:	nil,       opCode:	if kNewEndpoint then opSetNegotiate else opSetRequired,       form: 	'number,       data:	kMNPCompressionNone,       },       {label: kCMOMNPAllocate,       type:	'option,       opCode:	opSetRequired,       form:	'number,       data:	kMNPDontAllocate,       }       ],               				       // ----- "slow" Sharp IR ----- (see IRSample-3)              if kAll       then [       {label: kCMSSlowIR,		//"slir"       type: 	'service,       opCode: opSetRequired,	//0x0200       },       /*{label: kCMOSlowIRConnect,	// "irco"       type: 	'option,       opCode: opSetNegotiate,       data: {       	arglist: [ kNormalConnect ],		// later opened via Listen       	typelist: ['struct, 'ulong ] ,       	}       }*/       ],              // ----- serial IR ----- (see Basic Serial-2)              if kNewEndPoint       then {	// !!!a. serial IR (2.x). for 1.x, generate in initConfig ?       label:	kCMOSerialHWChipLoc,       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data:	{       	argList: [       		kHWLocBuiltInIR,       		0,       		],       	typeList: ['struct,       		['array, 'char, 4],       		'ulong,       		],       	},       },              // ----- 2.1 IrDA -----              if kNewEndPoint       then [       {		       label:	kCMSIrDA,			//"irda",       type:	'service,       opCode:	opSetRequired,       result:	nil,	       },        {label:	kCMOSerialBitRate,	//"sbps",		// serial bit rate       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'number,       data:	k115200bps,       },       {label:	kCMOIrDAReceiveBuffers,	//"irrb",	// IrDA recv buffers info       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data: {       	arglist: [       		512,	//buffSize ??       		1,		//numBuffs ??       		],       	typelist: [       		kStruct,       		kULong,       		kULong,       		],	       	},       },       {label:	kCMOIrDALinkDisconnectTimeout,	//"irld", // IrDA link disconnect threshold       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data:	{       	arglist: [       		40,					//discTime ??       		],       	typelist: [       		kStruct,       		kULong,       		],	       	},       },       {label:	kCMOIrDAConnectInformation,		//"irci",	// IrDA connect info       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data: {       	arglist: [       		0,		//Floor(StringToNumber(myID)) 	"0" ??       		0,		//Floor(StringToNumber(peerID)) "0" ??       		1,		//StrLen(myName)       		1,		//StrLen(peerName)       		"X",	//myName ??       		"X",	//peerName ??       		],       	typelist: [       		kStruct,       		kULong,       		kULong,       		kULong,       		kULong,       		[kArray, kChar, 0],       		[kArray, kChar, 0],       		],	       	},       },],              // ---- !!!i 115K.               k115200bps,       k230400bps,              // don't work. settings borrowed from Fast Serial by Filip R. Zawadiak: philz@wasko.gliwice.pl       /*       if kNewEndpoint then       [       {label: kCMSMNPID, type: 'service, opCode: opSetRequired},       {label: kCMOSerialIOParms, type:'option, opCode: opSetNegotiate,       	data: {       		arglist: [k1StopBits, kNoParity, k8DataBits, k115200bps],       		typeList: [10,1,2,1,1]}},       {label: "mnpn", type: 'option, opCode: opSetNegotiate,       	data: {       		arglist: [230400],       		typeList: [10,1]}},       {label: kCMOMNPCompression, type: 'option, opCode: opSetRequired,       	data: {       		arglist: [11],       		typeList: [10,1]}},       {label: kCMOMNPAllocate, type: 'option, opCode: opSetRequired,       	data: {       		arglist: [true],       		typeList: [10,5]}},       {label:kCMOMNPDataRate, type:'option, opCode: opSetNegotiate,       	data: {       		arglist: [k115200bps],       		typeList: [10,1]}}       ],       */       ],     viewQuitScript:       func()       begin       	:epDisconnect();       	local sym;       	foreach sym in '[       		newEntry, targetSoup, entryString, entryPara,       		entryBinary, entrySpec, entrySpecFunc, notes,       		reorienting, prefsEntry, prefsCurrent,       		Sloup, registerButton, configOptions,		// !!!f       		]       	do self.(sym) := NIL;              	if kBuild20 or nos20       	then UnRegPowerOff(kAppSymbol)       	else RemovePowerOffHandler(self);              	if kBuild20 and self.hideObj	// !!!g       	then begin       		GetRoot().notifyIcon:?KillAction(hideObj);       		hideObj := NIL;       		end;              	inherited:?viewQuitScript();       end,     viewDrawScript:       func() // 1.x       begin       	constant y := -1;       	local INT x := (viewBounds.right - viewBounds.left) div 2;       	:DrawShape(       		MakeOval(x-kDragRadius, y-kDragRadius, x+kDragRadius, y+kDragRadius), // left,top,right,bottom       		{transferMode: modeCopy,       		fillPattern: vfFillWhite,       		penSize: 2,       		});       end,     addFile:       func(type, href, content, options) // called via Newt's Cape       begin       	// check type etc.??  add a delay after each line??              	optionsAPI := if options then options else {};       	//if not optionsAPI.noStatus then       	self:open(); // could just do an :init?       	//:restartConn();       	targetSoup := notes := entrySpec := entryString := entryPara := entryBinary := NIL;              	local epos, spos := 0, s, slen := StrLen(content);       	local curState := 'waitForSoupName;              	loop begin       		epos :=       			if kBuild20       			then CharPos(content, unicodeCR, spos)              		else  StrPos(content, cr, spos);              		if spos < slen and content[spos] = unicodeLF	// !!!b,a       		then spos := spos+1;              		s := if epos // include cr       			then SubStr(content, spos, epos+1-spos)       			else SubStr(content, spos, nil) & unicodeCR;              		if curState = 'waitForSoupName       		then begin       			if :newSoupName(:newLine(s))       			then curState := 'waitForEntrySpec;       			end              		else if curState = 'waitForEntrySpec       		then begin       			if s := :newLine(s)       			then curState :=       				if BeginsWith(s,kBye)       					or not :buildEntrySpec(s)       				then 'waitForSoupName       				else 'waitForEntries;       			end              		else // waitForEntries       			if BeginsWith(s, kDump)       		then begin       			:dumpEntries(s);       			:restartConn();       			curState := 'waitForSoupName;       			end              		else if BeginsWith(s, kBYE)       		then begin       			if notes or (longStr and entryBinary)       			then :addNewEntry(:newLine(endOfPara))       			else :addIndexes(s,true);       			:restartConn();       			curState := 'waitForSoupName;       			end              		else if BeginsWith(s, kErase)       		then :eraseEntries()              		else if BeginsWith(s, kReplace)       		then :setReplaceSlot(s)              		else :addNewEntry(:newLine(s));              		if epos       		then spos := epos+1 // skip cr       		else break;       		//RefreshViews();       		end;              	TRUE;       end,     entrySpec: nil,     inspReset: nil,     viewFlags: 576,     NetworkChooserDone:       func(host, zone)       begin       	:setPreference('host, host);       	:setPreference('zone, zone);       	configOptions := :getConfigOptions(kADSPitem, host, zone, sloup); // !!!a       end,     dumpNoteString:       func(espec, entry, sfun, fieldSep, first, nameSep)       if kBuild20 and StrEqual(targetSoupName, kNewtworksSoupName)       then begin       	if espec.title       	then call kOutputStr with (commEndPt, entry.title & fieldSep);       	local dummy := BuildContext(kDummyTx);       	dummy:Open();       	dummy:Internalize(entry.saveData);       	call kOutputNewtWorksRange with (dummy, nil, commEndPt);       	dummy:close();       	TRUE;       	end              // this version writes out intermediate results rather than concatenating as a (big) string       else begin       	local obj, text, cl1 := espec.class, cl2 := entry.class;              	if nos20 and entry.topics and	// moved to beginning       		(not cl1 or cl1 = cl2) and Length(entry.topics) > 0       	then begin       		constant tabs := "\t\t\t\t\t\t\t\t\t\t\t\t";       		:dumpNoteExtra(espec, entry, sfun, fieldSep, first, nameSep);       		foreach obj in entry.topics       		do if IsString(text := Clone(obj.text)) and not IsRichString(text)       		then begin       			//if first then :setEntry(text); // display 1st para       			call kFixCR with (commEndPt, text);	// !!!g       			call kOutputStr with (commEndPt,       				// nameSep ??? !!!i       				(if first       				then first := NIL       				else crlf) & // between lines       				(if obj.level and obj.level > 1 then SubStr(tabs, 0, obj.level-1)) &       				text);       			end;       		return TRUE;       		end              	else if not nos20 or not cl1 or cl1=if cl2 then cl2 else kPaperRollSym       	then begin       		:dumpNoteExtra(espec, entry, sfun, fieldSep, first);       		if entry.data	// moved test here to allow other stationery to be dumped       		then foreach obj in entry.data       			do if (text := Clone(obj.text)) and       				(if kBuild20 then IsString(text) else isInstance(text,'string))       				and not (nos20 and IsRichString(text))       			then begin       				//if first then :setEntry(text); // display 1st para       				call kFixCR with (commEndPt, text);	// !!!g       				call kOutputStr with (commEndPt,       					// nameSep ??? !!!i       					(if first       					then first := NIL       					else fieldSep) & // between paras       					if StrLen(text) > 0       					then text);       				end;       		return TRUE;	// final record delim (e.g., -----) cr&flush in dumpEntries       		end;              	//NIL;       end	,     BitmapFromRawData:       DefineGlobalConstant('kColorTable16,       SetLength(       SetClass("\uF000F000F000F000E000E000E000E000D000D000D000D000C000C000C000C000B000B000B000B000A000A000A000A0009000900090009000800080008000800070007000700070006000600060006000500050005000500040004000400040003000300030003000200020002000200010001000100010000000000000000000"       ,'grayPattern), 128)       );              DefineGlobalConstant('kColorTable4,       SetLength(       SetClass("\uF000F000F000F000A000A000A000A00050005000500050000000000000000000"       ,'grayPattern), 32)       );              func (rawData, byteOffset, byteCount, INT pixelWidth, rowByteMultiple, INT bitdepth)       // note: ready for native, but only modest improvement       /*return value    - bitmap frame {bits: <binary obj>, bounds: <bounds frame>}         rawData         - binary object containing pixel data         byteOffset      - offset where pixel data begins in rawData (nil -> default 0)         byteCount       - number of bytes of pixel data in rawData (nil -> use Length(rawData) or StrLen(rawData))         pixelWidth      - number of pixels per row in the bitmap         rowByteMultiple - specifies byte alignment of rawData. I.e. rows of rawData are                            padded to be a multiple of rowByteMultiple bytes (nil -> default 1)                            (assume rawData is byte-aligned at the very least)       Builds a bitMap up from raw data.       */       if rawData and pixelWidth       then begin       	local INT boff	:= if byteOffset then byteOffset else 0;       	local INT rbm	:= if rowByteMultiple then rowByteMultiple else 1;       	local INT bc;       	if byteCount       	then bc := byteCount       	else begin       		bc := Length(rawData) - boff;       		//try to be smart and ignore null terminating bytes on strings       		if IsSubClass(ClassOf(rawData), 'string)       		then bc := bc - 2;       		end;              	//calculate rawData's rowBytes       	local INT rbm8 := 8*rbm;       	local INT rawBytesPerRow := rbm*((pixelWidth*bitdepth + rbm8-1) DIV rbm8);              	//#bytes they gave us must be a multiple of rawBytePerRow       	if (bc MOD rawBytesPerRow) <> 0       	then Throw('|evt.ex.msg|,"pixelWidth (" & pixelWidth & "), byteCount (" &       		bc & "), and rowByteMultiple (" & rbm & ") inconsistent");              	//calculate our rowBytes (always a multiple of 4)       	local INT rowBytes  := 4*((pixelWidth*bitdepth + 31) DIV 32); //4*Ceiling(pixelWidth/32)       	local INT pixelHeight := bc DIV rawBytesPerRow;               	//create bitmap with header initialized to zero       	local myBits;       	if kBuild20       	then myBits := MakeBinary(16, 'bits)       	else begin       		myBits := Clone("\u00000000000000000000000000000000");       		SetClass(myBits,'bits);       		end;              	StuffWord(myBits,  4, rowBytes);    // kBMRowBytesOffset       	StuffWord(myBits, 12, pixelHeight);	// kBMBotOffset       	StuffWord(myBits, 14, pixelWidth);  // kBMRightOffset              	if rawBytesPerRow = rowBytes       	then        		begin       		//BinaryMunger(myBits,kBitmapHeadLen,nil, rawData,byteOffset,byteCount) // kBMPixelOffset       		SetClass(rawData, 'bits);       		SetLength(rawData, bc);       		myBits := BinaryMunger(rawData, 0, boff, myBits, 0, kBitmapHeadLen);       		end       	else begin       		local INT outputLength := kBitmapHeadLen + (pixelHeight*rowBytes); // kBMPixelOffset       		SetLength(myBits, outputLength);       		local int rawIndex := boff, myBitsIndex;       		for myBitsIndex := kBitmapHeadLen to outputLength by rowBytes // kBMPixelOffset       		do begin       			BinaryMunger(myBits,myBitsIndex,rawBytesPerRow, rawData,rawIndex,rawBytesPerRow);       			rawIndex := rawIndex + rawBytesPerRow;       			end;       		end;                	if kBuild20 and bitdepth > 1       	then {       		bounds: RelBounds(0, 0, pixelWidth, pixelHeight),       		colordata: {       			cbits: SetClass(myBits, 'cbits),       			bitdepth: bitdepth,       			colortable: if bitdepth=4 then kColorTable16 else kColorTable4},       		}              	else {       		bounds: RelBounds(0, 0, pixelWidth, pixelHeight),       		bits: myBits,       		};       end,     addNewEntry:       func(s) // Add a new entry into the soup.       if targetSoup and s and (if isArray(s) then Length(s) else StrLen(s)) > 0       then begin       if kProfileOn and not profilingOn       then EnableProfiling(profilingOn := true); // turn off in restartConn              	newEntry := NIL;       	entryIndex := 0;	// !!!h. moved earlier              	if notes       	then begin       		local INT maxWid := GetAppParams().appAreaWidth - 4;       		local ht, spos, line1, vf := if entrySpec then entrySpec.viewFont, cl := entrySpec.class;       		local newSpec := Clone(entrySpec);	// !!!h. keep title and possible other slots       		RemoveSlot(newSpec, 'labels);       		RemoveSlot(newSpec, 'viewFont);       		RemoveSlot(newSpec, 'class);       		RemoveSlot(newSpec, 'height);              		if not vf       		then vf := if kBuild20 or nos20       			then GetUserConfig('userFont)       			else call kGetUserConfigFunc with ('userFont);       		if isArray(s) // list or checkList       		then begin       			local topics := [], topic, level, left, top := 7;       			if Length(newSpec) > 0	// !!!h. entrySpec.title       			then begin       				entryString := s[0];	// !!!h       				if EndsWith(entryString,cr) then StrMunger(entryString,StrLen(entryString)-1,1,nil,0,nil);	// !!!h       				ArrayRemoveCount(s,0,1);       				end;       			local left0 := if cl='checkList then 43 else 28;       			foreach topic in s       			do begin       				level := 1;       				while topic[0]=$\t       				do begin       					level := level+1;       					StrMunger(topic,0,1,nil,0,nil);       					end;       				if EndsWith(topic,cr)       				then StrMunger(topic,StrLen(topic)-1,1,nil,0,nil);       				left := left0 + 20*(level-1);       				ht := if kBuild20 or nos20       					then TextBounds(topic,vf,RelBounds(0,0,maxWid-left,0)).bottom       					else call kSimpleTextHeightFunc with (topic,maxWid-left,vf);       				AddArraySlot(topics, {       					mtgDone: nil,       					styles: [StrLen(topic), vf],       					hideCount: 0,       					viewBounds: RelBounds(left,top,maxWid-left,ht),       					level: level,       					text: topic,       					});       				top := top + ht + 6;       				end;       			newEntry := {       				viewStationery: kPaperRollSym,       				class: cl,       				height: top+60,       				data: NIL,       				topics: topics,       				timeStamp: Time(),       				};       			end              		else begin       			spos := if kBuild20 then CharPos(s, unicodeCR, 0) else StrPos(s, cr, 0);       			line1 := SubStr(s,0,spos); // even if no official title       			if (kBuild20 or nos20) and Length(newSpec) > 0	// !!!h       			then begin       				entryString := line1;	// !!!h       				StrMunger(s,0,spos+1, nil,0,nil);       				end;              			if kBuild20 and StrEqual(targetSoupName, kNewtworksSoupName)       			then newEntry := {       				title: LocObj("untitled", 'untitledLabel),       				data: {text: s, styles: [StrLen(s), vf]},       				}              			else begin       				ht := if entrySpec then entrySpec.height;       				if not ht       				then ht := (2 * FontHeight(vf)) + // a little more space       					if kBuild20 or nos20       					then TextBounds(s,vf,RelBounds(0,0,maxWid-noteLeft,0)).bottom       					else call kSimpleTextHeightFunc with (s,maxWid-noteLeft,vf);              				newEntry := {       					viewStationery: kPaperRollSym,       					height: ht,       					data: [{       						viewStationery: 'para,       						viewBounds: RelBounds(noteLeft, noteTop, maxWid-noteLeft, ht),       						text: s,       						viewFont: vf,       						}],       					timeStamp: Time(),       					};       				if kBuild20 or nos20       				then begin       					newEntry.class := if cl then cl else kPaperRollSym; // !!!f       					newEntry.topics := NIL;       					end;       				end;       			end;              		local elabel := entrySpec.labels, slot, val;       		if (if kBuild20 then IsSymbol(elabel) else isInstance(elabel, 'symbol))       		then newEntry.labels := elabel;              		if Length(newSpec) > 0	// !!!h. generally copy additional slots (like title) to newEntry       		then foreach slot,val in :buildEntry(newSpec,TRUE)       			 do newEntry.(slot) := val;       		//if title then newEntry.title := title;              		if replaceSlot       		then begin       			local cursor :=       				if kBuild20 or nos20       				then targetSoup:Query(nil)       				else Query(targetSoup,kDefaultIndex);       			local entry := cursor:entry(), edata, title := newEntry.title;       			while entry       			do begin       				if call kLabelEqual with (elabel, entry.labels) and       					(if title       					then entry.title and StrEqual(entry.title, title)	// !!!h       					else IsArray(edata := entry.data) and       						Length(edata) > 0 and       						BeginsWith(edata[0].text, line1))       				then break if kBuild20       					then EntryRemoveFromSoupXmit(entry,nil)       					else EntryRemoveFromSoup(entry);       				entry := NIL;       				entry := cursor:next();       				end;       			cursor := nil;       			end;       		end              	else begin       		// Now initialize the new entry by cloning the       		// entry specification we got earlier.  This is       		// a frame with the same slots as a soup entry,       		// with sample slot values that are used to       		// specify the desired type for the data.              		entryString := s;       //if BeginsWith(s,"Personal") then Print(StrLen(s));              		newEntry := Clone(entrySpec);       		newEntry := :buildEntry(newEntry,TRUE);              		// Fix the sortOn slot in the entry.       		// The sortOn slot contains a reference to the string in       		// either the names.last slot or the company slot.       		// This allows the Names app to keep a single index       		// on the sortOn slot, while still sorting by       		// either the names.last or company slotc values...       		if StrEqual(targetSoupName, cardSoupName)       		then newEntry.sortOn :=       			if newEntry.sortOn = 'name       			then SetClass(newEntry.name.last, 'name)       			else SetClass(newEntry.company, 'company);              		if replaceSlot and newEntry       		then if isFrame(targetSoup)       			then begin       				local entry := :getEntry(targetSoup, replaceSlot, newEntry.(replaceSlot));       				if entry       				then if kBuild20       					then EntryRemoveFromSoupXmit(entry, nil)       					else EntryRemoveFromSoup(entry);       				end       			else if kBuild20 and StrEqual(targetSoupName, kPackage)       			then begin       				local pkg, pkgName, store;       				if replaceSlot and pkgName := newEntry.(replaceSlot)       				then foreach store in GetStores()       					do if pkg := GetPkgRef(pkgName, store)       					then begin       						:setStatus(LocObj("removing package", 'removingPackage));       						RefreshViews();       						SafeRemovePackage(pkg);       						end;       				end;       		end;              	entryPara := entryString := entryBinary := NIL;              	if newEntry       	then begin       		if kBuild20 and StrEqual(targetSoupName, kNewtworksSoupName)       		then call kNewtWorksNewDoc with (newEntry.title, newEntry.data, nil, nil, newEntry.labels)       			       		else if isFrame(targetSoup)       		then begin       			// add any entry to default store       			if kBuild20       			then targetSoup:AddToDefaultStoreXmit(newEntry, nil)       			else targetSoup:AddToDefaultStore(newEntry);              			// Flush our changes...       			// targetSoup:Flush();              			// Tell the rest of the world that something has changed.       			//BroadcastSoupChange(targetSoupName); // do at BYE time once       			end              		else if kBuild20 and StrEqual(targetSoupName, kPackage)       		then begin       			:setStatus(LocObj("installing package", 'installingPackage));       			RefreshViews();       			//GetDefaultStore():SuckPackagefromBinary(newEntry.packageEntry, {});                     		// !!!i              		local /*frame*/ progressOptions := {              			closeBox: nil,              			//icon: icon,               			statusText: kVersion,              			gauge: 0,							// 0-100              			titleText: LocObj("installing package", 'installingPackage) & $: && newEntry.packageName,              			};                     		DoProgress('vGauge, progressOptions, func(progressView)              			try GetDefaultStore():SuckPackagefromBinary(              				newEntry.packageEntry,       					{callbackFreq: 1024,	// callbackFrequency wrong in docs!       					 callBack: func(callbackInfo)       						begin       							progressOptions.gauge := RIntToL(callbackInfo.amountRead / callbackInfo.packageSize * 100);       							progressView:SetStatus('vGauge, progressOptions);       						end,       					});       				onexception |evt.ex|       				do begin       					newEntry := currentException();       					if newEntry.error       					then newEntry := newEntry.error       					else if newEntry.data       					then newEntry.newEntry.data.errorCode;       					:errorStatus(LocObj("error", 'errorMsg) & $: && newEntry);       					newEntry := nil;       					end;       			);       			if not newEntry then return; // error so don't lose error msg       			end;              		newEntry := NIL;       		:setNumEntries(numEntries+1);       		:setStatus("");       		end;       end,     targetSoup: nil,     setEntry:       func(txt)       if currentEntryDisplay and txt       then SetValue(currentEntryDisplay, 'text, txt),     configOptions: nil,     ReorientToScreen:       func() //@588 // ROM_DefRotateFunc       begin       	reorienting := true;       	:SyncViews();       	:RedoChildren();       	reorienting := nil;       end,     newSoupName:       func(s)       if s       then begin       	s := TrimString(s); // get rid of cr & trailing spaces       	local spos := if kBuild20 then CharPos(s, $!, 0) else StrPos(s, kExcl, 0), aindex, slist, v;       	local soupName := if spos then SubStr(s,0,spos) else s;              	:setNumEntries(0);	// !!!a. moved earlier       	SetValue(numIndexes, 'text, eString);       	SetValue(soupNameDisplay, 'text, eString);       	//if kAll and IR	// !!!a       	//then commEndPt:SetInputSpec(nil);	// gets reset in waitForName              	targetSoup :=       		if spos       		then if BeginsWith(s, kErase) or BeginsWith(s, kBye) or       				BeginsWith(s, kReplace)       			then return NIL              			else if BeginsWith(s, kDump)       			then begin       				local store;       				foreach store in GetStores()       				do begin       					call kOutputStr with (commEndPt, LocObj("Store", 'storeLabel) & $: && store:GetName() & crlf);       					foreach soupName in store:GetSoupNames()       					do begin       						call kOutputStr with (commEndPt, soupName & crlf);       						:setNumEntries(numEntries+1);	// !!!a       						end;       					call kOutputStr with (commEndPt, endOfPara & crlf);       					end;       				call kOutputStr with (commEndPt, kBYE & crlf);	// !!!a       				return NIL;       				end              			else if BeginsWith(s, kEval)       			then begin       				try       					:print(call Compile (SubStr(s, spos+1, nil)) with ());       				onexception |evt.ex|       				do begin       					:print(kError);       					:print(currentException());       					end;       				return NIL;       				end              			else call kMyRegCardSoup with (	// possibly create it       					soupName,        					if isArray(aindex := :addIndexes(s,nil)) then aindex else aindex := [],       					kAppSymbol,       					["datum","data"]       					)       		else if StrEqual(soupName, kSloup) or StrEqual(soupName, kSlurpee)       		then TRUE       		else if StrEqual(soupName, kPackage)       		then kBuild20       		else if kBuild20 and StrEqual(soupName, kNewtworksSoupName)       		then (if GetRoot().(kNewtworksSym) then GetUnionSoupAlways(soupName)) // for DUMP only       		else if StrFilled(s)       		then GetUnionSoup(soupName); // use existing only              	if targetSoup       	then begin       		targetSoupName := soupName;       		if Visible(sloup)       		then begin       			SetValue(soupNameDisplay, 'text, soupName);       			SetValue(numIndexes, 'text, SPrintObject(       				if isFrame(targetSoup) and       					isArray(slist := if kBuild20 or nos20       						then targetSoup:GetSoupList()       						else targetSoup.soupList) and       					Length(slist) > 0       				then Length(slist[0]:getIndexes())       				else if aindex then Length(aindex)));       			:setStatus(kWaitingEntrySpec);       			:setEntry("");       			end;              		notes := StrEqual(soupName, noteSoupName)       			or (kBuild20 and StrEqual(targetSoupName, kNewtworksSoupName));       		end       	else if StrFilled(soupname) // ignore empty lines       		and Visible(sloup)       	then :setEntry(LocObj("not a soupname/index", 'notSoupIndex) & $: && s);              	entryString := entryPara := entryBinary := longStr :=       		newEntry := replaceSlot := NIL;              	targetSoup;       	end,     optionsAPI: nil,     viewBounds: {left: 16, top: 34, right: 224, bottom: 206},     Print:       func(v) // a simpler print. mostly to show how it can be done. used by paste, dumpEntries, newSoupName, readEvalPrint       if commEndPt and GetRoot().(kNewtSymbol) // !!!f       then GetRoot().(kNewtSymbol):PrintObject(v, commEndPt, 99, true, "", cr) // lfs added       else begin       	local s := call kMySPrintObject with (v);       	call kFixCR with (commEndPt, s);	// !!!g. replace all crs with crlfs (otherwise, TE may overwrite)       	call kOutputStr with (commEndPt, s & crlf);       	end,     prefsCurrent:       {inspect: nil,       sound: 	true,       connect: true,       refresh: true,       bps: 		0, 	//"9600",       host: 	nil, 	// for ADSP       zone: 	nil,       },     _proto: @180 /* protoFloatNGo */,     buildBinary:       func(value)       if StrEqual(value,kBitmap) or StrEqual(value,kBits)       then begin       	local bframe := :BitmapFromRawData(       			:Ustring(nil, entryString, entryIndex, nil, 'bits),       			nil, nil, newEntry.width, 4,       			if newEntry.bitdepth then newEntry.bitdepth else 1);       	local bname := SPrintObject(newEntry.name), entry, slast := StrLen(bname)-1;       	if bname[slast] = $!	// !!!h. EndsWith(bname, "!")       	then if entry := :getEntry(targetSoup, 'name, Intern(SubStr(bname,0,slast))) // StrLen(bname)-1)))       		then begin       			entry.bitmap.mask := bframe.bits;       			if kBuild20       			then EntryFlushXmit(entry, nil)       			else EntryChange(entry);       			RETURN bframe := NIL;       			end       		else bframe       	else bframe; // store normally       	end              else if StrEqual(value,kSamples) or StrEqual(value,kSound)       then {       	sndFrameType: 'simpleSound,        	samples: :Ustring(nil, entryString, entryIndex, nil, 'samples),       	samplingRate: newEntry.samplingRate, // remove from soup frame itself?       	dataType: k8bit, 		// 1       	compressionType: kNone, // 0       	}              else :Ustring(nil, entryString, entryIndex, nil, Intern(value)) // picture, resource       ,     entryBinary: nil,     protoSerialProtocol:       DefineGlobalConstant('kProtoInputSpec,	// !!!a       if kNewEndPoint       then {       	form:			'string,       	termination:	{endSequence: unicodeCR},       	//filter: 		{byteProxy: [{byte: unicodeLF, proxy: nil}]}, // replace with kFilterLFtoCR for Unix?       	discardAfter:	5000,       	InputScript:	func(ep, data, terminator, options)	// 2.x: 4 args       		begin // filter doesn't really work?       			if termination.endSequence = unicodeCR       			then (if data[0] = unicodeLF       					then StrMunger(data,0,1,nil,0,nil))       			else data[StrLen(data)-1] := unicodeCR;       			// data now a proper line (ending w/ cr, containing no lf)       			:lineScript(ep, data);       		end,       	}       else {       	InputForm: 		'string,       	endCharacter:	unicodeCR,       	discardAfter:	5000,        	InputScript: 	func(ep, data)	// 1.x: 2 args       		begin       			if endCharacter = unicodeCR       			then (if data[0] = unicodeLF       					then StrMunger(data,0,1,nil,0,nil))       			else data[StrLen(data)-1] := unicodeCR;       			:lineScript(ep, data);       		end,       	}       );       //DefineGlobalConstant('kFilterLFtoCR, {byteProxy: [{byte: unicodeLF, proxy: unicodeCR}]});       DefineGlobalConstant('kTerminationLF, {endSequence: unicodeLF});                     {_proto: if kNewEndPoint		// !!!d,a       	then //if kAddEncoding then NTE_protoBasicEndpoint else       		protoBasicEndPoint       	else protoEndPoint,              configOptions: [	// replace this for ADSP, IR       	{label: kCMSAsyncSerial,       	type: 	'service,       	opCode: opSetRequired,       	result:	nil,       	},              	{label: kCMOSerialIOParms,       	type: 'option,       	opCode: if kNewEndPoint then opSetRequired else opSetNegotiate,       	result:	nil,       	form:	'template,       	data: 	if kNewEndPoint		// modify within initConfig for 19200,...       		then {       			arglist: [       				k1StopBits,		// 1 stop bit       				kNoParity,		// no parity bit       				k8DataBits,		// 8 data bits       				k9600bps,		// data rate in bps		// ***       				],       			typelist: ['struct,       				'long,			// stop bits       				'long,			// parity       				'long,			// data bits       				'long,			// bps       				],       			}       		else {       			bps: k9600bps, dataBits: k8DataBits,		// ***       			stopBits: k1StopBits, parity: kNoParity,       			},       	},              	{label: kCMOInputFlowControlParms,       	type: 	'option,       	opCode: if kNewEndPoint then opSetRequired else opSetNegotiate,       	result:	nil,       	form:	'template,       	data: 	if kNewEndPoint       		then {       			arglist: [       				unicodeDC1, 	// xonChar	       				unicodeDC3, 	// xoffChar	       				true, 			// useSoftFlowControl	       				nil, 			// useHardFlowControl	       				0, 				// not needed; returned	       				0, 				// not needed; returned       				],       			typelist: ['struct,       				'byte,			// XON character       				'byte,			// XOFF character       				'boolean,		// software flow control       				'boolean,		// hardware flow control       				'boolean,		// hardware flow blocked       				'boolean,		// software flow blocked       				],       			}       		else {       			xonChar: kDefaultXOnChar,  	//unicodeDC1,       			xoffChar: kDefaultXOffChar, //unicodeDC3,       			useSoftFlowControl: true, useHardFlowControl: nil,       			},       	},              	{label: kCMOOutputFlowControlParms,       	type:  'option,       	opCode: if kNewEndPoint then opSetRequired else opSetNegotiate,       	result:	nil,       	form:	'template,       	data: 	if kNewEndPoint	// share with kCMOInputFlowControlParms in afterScript       		then {       			arglist: [       				unicodeDC1, 	// xonChar	       				unicodeDC3, 	// xoffChar	       				true, 			// useSoftFlowControl	       				nil, 			// useHardFlowControl	       				0, 				// not needed; returned	       				0, 				// not needed; returned       				],       			typelist: ['struct,       				'byte,			// XON character       				'byte,			// XOFF character       				'boolean,		// software flow control       				'boolean,		// hardware flow control       				'boolean,		// hardware flow blocked       				'boolean,		// software flow blocked       				],       			}       		else {       			xonChar: kDefaultXOnChar,  	//unicodeDC1,       			xoffChar: kDefaultXOffChar, //unicodeDC3,       			useSoftFlowControl: true, useHardFlowControl: nil,       			},       	},              	// increase input buffer to 1024. see Q&A: Endpoint I/O Data Buffers & Flow Control (10/5/94)       	{label:	kCMOSerialBuffers,       	type:	'option,       	opCode:	opSetRequired,       	form: 	'template,		// not needed       	result: nil,			// not needed; returned       	data : if kNewEndPoint       		then {       			arglist: [       				256, 		// use 256 byte transmit buffer       				1024,	 	// use 1K byte receive buffer       				8, 			// remember up to 8 error characters       				],       			typelist: [       				'struct,       				'ulong,		// output buffer size in bytes       				'ulong, 	// input buffer size in bytes       				'ulong, 	// error characters to remember       				],       			}       		else [ 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 8 ],       	},              	// add to this for kNewEndPoint(serial)       	],              exceptionHandler: func(exception)       	nil, // Print(exception),       	//SetValue(sloup.StatusBox, 'text, "exceptionHandler called..."),              Output: func(data, options)	// !!!a. 1.x-compatible       begin       	if kNewEndpoint       	then begin       		/* local gData := GetGlobalVar(kNewtsCapeSymbol), addEncoding;       		if gData and gData.protos and (addEncoding := gData.protos.NTEforFORM)       		then data := call addEncoding with (data);       		*/              		inherited:Output(data, options, nil);	// 2.x. which outputSpec to use?       		end       	else begin       		// only 2 args! for protoEndpoint       		inherited:Output(data, if options then options else if kAll then receiveFlags); // 1.x       		if kBuild1x //and FlushActive = 0       		then :FlushOutput();       		end;       	if kAll and (receiveFlags or (kBuild1x and sloupType = kADSPitem)) // IR, ADSP?       	then Sleep(kOutputDelay);       end,              flushOutput: func()	// !!!a. remove for 1.x. no-op for 2.x       if kBuild1x       then inherited:FlushOutput(),              firstLineSpec:	{ // for very first line       	_proto: 		kProtoInputSpec,       	termination:	{byteCount: 1},	// 2.x (remove in afterScript for 1.x)       	byteCount: 		1,				// 1.x (remove in afterScript for 2.x)       	InputScript:       		if kNewEndpoint       		then func(ep, data, terminator, options)       				:lineScript(ep, data)       		else func(ep, data)       				:lineScript(ep, data),	// use directly in afterScript              	lineScript: func(ep, data)       	begin       		local spec, sym, otherSpecs := ep.otherSpecs;       		if data[0] = unicodeLF // StrEqual(data,lf)       		then begin       			// modify other inputSpecs to use LF       			foreach sym in otherSpecs       			do ep.(sym) :=       					if kNewEndpoint       					then {       						_proto: 	 ep.(sym),       						termination: kTerminationLF,       						}       					else {       						_proto: 	  ep.(sym),       						endCharacter: unicodeLF,       						};       			end       		else if data[0] <> unicodeCR // StrEqual(data,cr)       		then return ep.tempLine := ep.tempLine & data;		// save/continue              		// check that each has InputScript (if not, provide default)       		foreach sym in otherSpecs       		do begin       			spec := ep.(sym);       			if not spec.InputScript	// e.g. Newt's Cape       			then begin       				if isReadonly(spec)       				then ep.(sym) := spec := {_proto: spec};       				spec.InputScript := kProtoInputSpec.InputScript;       				end;       			end;       		ep.firstLine := true;       		ep:SetInputSpec(spec := ep.(otherSpecs[0])); 	// switch to first spec for next line(s)       		spec:?lineScript(ep, ep.tempLine & unicodeCR); 	// handle 1st line       	end,       	},              otherSpecs: '[waitForSoupName, waitForChar, waitForEntrySpec, waitForEntries, ], // see restartConn              waitForSoupName: {       	_proto: kProtoInputSpec,       	lineScript: func(ep, data)       		if ep:newSoupName(ep:newLine(data))       		then ep:SetInputSpec(ep.waitForEntrySpec),       	},              waitForEntrySpec: {       	_proto: kProtoInputSpec,       	lineScript: func(ep, data)       		if data := ep:newLine(data)       		then ep:SetInputSpec(       			if BeginsWith(data,kBye)       				or not ep:buildEntrySpec(data)       			then ep.waitForSoupName       			else ep.waitForEntries),       	},              waitForEntries: {       	_proto: kProtoInputSpec,       	lineScript: func(ep, data)       		if BeginsWith(data, kDump)       		then begin       			ep:dumpEntries(data);       			ep:restartConn();       			end              		else if BeginsWith(data, kBYE)       		then begin       			if GetVariable(ep,'notes) or       				(GetVariable(ep,'longStr) and GetVariable(ep,'entryBinary))       			then ep:addNewEntry(ep:newLine(endOfPara))       			else ep:addIndexes(data,true);       			ep:restartConn();       			end              		else if BeginsWith(data, kErase)       		then ep:eraseEntries()              		else if BeginsWith(data, kReplace)       		then ep:setReplaceSlot(data)              		else ep:addNewEntry(ep:newLine(data)),       	},              postString: func(data,r,fast)       	begin       		local hview := HiliteOwner(), offset, kview := GetView('viewFrontKey), tx;       		local start := 0, count := 0, newstart;       		if fast and hview and (tx := hview.text)       			and ((hview=kview and (offset := GetHiliteOffsets()[0])       						and (start := offset[1]) and (count := offset[2]-start))       				or StrLen(tx)=0)          		then begin       				// if hilite (or empty), insert directly into a normal view       				newstart := start+StrLen(data);       				StrMunger(tx, start, count, s, 0, nil); // replace range       				StrMunger(tx, newstart, 0, " ", 0, nil);  // insert a space for new hilite       				SetValue(hview,'text, tx);       				hview:SetHilite(newstart, newstart+1, true);       				end       		else PostKeyString(kview, data); // no hilite, or Notepad-like              		if prefsCurrent.soundSym       		then PlaySound(protokeypad.keySound);       		if r then RefreshViews();       	end,              waitForChar: {       	_proto: kProtoInputSpec,       	partialFrequency: 250,              	lineScript: func(ep, data)       		ep:postString(data,true,true),              	PartialScript: func(ep, data)       	begin       		StrReplace(data,lf,"",nil);       		local sloup := GetRoot().(kAppSymbol);       		local keySettings := sloup.sloupSpec;       		local INT i;       		//if kAll and IR 				// !!!a       		//then ep:SetInputSpec(nil);              		if keySettings.debug and StrFilled(data)       		then begin       			local INT num := Ord(data[0]);       			local sval := Clone("\\u0000");       			for i := 2 to 5       			do sval[i] := kHex[Band(num >> ((5-i) * 4), 0xF)];       			call kOutputStr with (ep, sval & crlf);       			end;              		//ep:SetInputSpec(ep.waitForChar); // set up for next char        		ep:FlushPartial();               		local newtView := GetRoot().(kNewtSymbol);       		local frontView := GetView('viewFrontMost);       		local frontKeyView := GetView('viewFrontKey);              		if frontKeyView       		then begin       			if StrPos(data,keySettings.clearKey,0)       			then begin // "clear" current field       				if newtView and frontKeyView=newtView.para       				then newtView:revertNote(newtView.target,newtView) // Revert       				else SetValue(frontKeyView, 'text, Clone(eString));// Erase       				if sloup.prefsCurrent.soundSym then PlaySound(kEraseSound);       				end               			else if StrPos(data,keySettings.evalKey,0) or       					StrPos(data,keySettings.enterKey,0)       			then begin // "compile/eval" current field/selection       				data := ep:getSelection(frontKeyView);       				if sloup.prefsCurrent.soundSym then PlaySound(kEvalSound);       				if newtView       				then       					if newtView and frontKeyView=newtView.para       						and s=frontKeyView.text // no selection       					then newtView:saveNote(newtView.target,newtView) // Save       					else newtView:readEvalPrint(data);  // Eval       				else ep:readEvalPrint(data);					       				end               			else if StrPos(data,keySettings.closeKey,0)       			then frontView:?close()              			else if StrPos(data,keySettings.scrollUpKey,0)       			then frontView:?viewScrollUpScript();              			else if StrPos(data,keySettings.scrollDownKey,0)       			then frontView:?viewScrollDownScript();              			else begin // add char/str to current key view       				local sub := keySettings.keyboardMap;       				if isArray(sub)       				then for i:=0 to Length(sub)-1 by 2       					 do StrReplace(data,sub[i],sub[i+1],nil);	// fixCR?              				ep:postString(data,nil,nil);       				end;              			RefreshViews();       			end;       		//if kAll and IR 				// !!!a       		//then ep:SetInputSpec(ep.waitForChar);       	end,       	},              /*       connectComplete: func(options, result)       if result       then :MNotify(LocObj("Connect Error", 'connectErr), result)       else begin       	if kNewEndPoint and IR       	then try :Accept(nil, nil)       		onexception |evt.ex.comm|       		do return :MNotifyError("Accept", CurrentException().error);              	// sloup is _parent       	commEndPt := ep;       	:restartConn();       	if connButton       	then SetValue(connButton, 'text, kDisconnect);       	connStatus:?update();       	inspReset := GetRoot().(kNewtSymbol):?setInspector(commEndPt,nil);       	end,       */              disconnectComplete: func()	//(options, result)       begin       	//if result       	//then :MNotify(LocObj("Disconnect", 'disconnectLabel) && LocObj("Error", 'errorMsg), result);              	if kNewEndPoint       	then begin       		try :Cancel(nil)       		onexception |evt.ex.comm|       		do nil;              		try :Disconnect(nil,nil)       		onexception |evt.ex.comm|       		do nil;              		try :UnBind(nil)       		onexception |evt.ex.comm|       		do nil;       		end              	else begin       		try :Disconnect()       		onexception |evt.ex.comm|       		do nil;       	       		try if kAll       			then if sloupType=kSerialIRitem       				then call kEnableIRModuleFunc with (nil)       				else if sloupType=kADSPitem       				then CloseAppleTalk();       		onexception |evt.ex.comm|       		do nil;       		end;              	try :Dispose()       	onexception |evt.ex.comm|       	do nil;       	       	:setStatus(kDisconnected);	// _parent i.e. caller       	NIL;       end,              /* supposedly not needed anymore for 1.x       flushActive: 0,              flushOutput: func()       	// this is supposed to prevent some nasty race conditions if another flushOutput is in progress       	// it shouldn't affect us, but since it's recommended...       	if FlushActive = 0       	then begin       		FlushActive := FlushActive + 1;       		inherited:FlushOutput();       		FlushActive := FlushActive - 1;       		end,       */              /*       SetInputSpec: func(spec)	// !!!a. include slight delay for IR       if receiveFlags	// IR?       then begin       	if spec       	then Sleep(1)			// at least 3 ms (1 tick = ~16ms)       	else try :Cancel(nil) onexception |evt.ex.comm| do nil;       	inherited:SetInputSpec(spec);       	if not spec       	then Sleep(1);       	end       else inherited:SetInputSpec(spec),       */       },     nextInputString:       func NATIVE ()       begin       	local field := "", s := entryString;       	local INT si, ei := entryIndex;       	local sPos := StrPos(s, sloupSpec.fieldDelimiter, ei);              	if sPos or       		(sPos := if kBuild20 then CharPos(s, unicodeCR, ei) else StrPos(s, cr, ei)) or       		(sPos := StrLen(s))       	then begin       		si := sPos;       		field :=       			if sloupSpec.stripQuotes and s[ei]=$" and s[si-1]=$"       			then SubStr(s, ei+1, si - ei - 2)       			else SubStr(s, ei,   si - ei);       		entryIndex := si + 1;       		end;       	field;       end,     getSelection:       func(frontView)       if frontView       then if HiliteOwner() and GetHiliteOffsets()       	then begin       		local ARRAY offset;       		local s, txt;       		local INT start, stop;       		foreach offset in GetHiliteOffsets() // handle multiple selections       		do begin       			frontView := offset[0];       			start := offset[1];       			stop  := offset[2];       			s := s &       				(if kBuild20 and GetRoot().(kNewtworksSym) and frontView.GetRangeData // !!!c       				then call kOutputNewtWorksRange with (frontView, {first: start, last: stop}, nil)       				else if isInstance(txt := if frontView.realData then frontView.realData.text else frontView.text, 'string)	// !!!f       					//count>1 // not just a single char ("pseudo highlight range") ???       				then SubStr(txt,start,stop-start)       				) & unicodeCR;       			end;       		s;       		end              	// !!!c. added cr       	else if frontView.text          // normal text field. entire field       	then frontView.text & unicodeCR       	else if kBuild20 and GetRoot().(kNewtworksSym) and frontView.GetRangeData // !!!c       	then call kOutputNewtWorksRange with (frontView, nil, nil)       	else if frontView.realData // Notepad       	then frontView.realData.text       	else eString       else eString,     openEndpoint:       func(options, host, zone, caller, type)	// !!!a. called by 'app' (e.g., Newt's Cape), epConnect       if (if kBuild20 then IsInteger(type) else isInstance(type, 'int)) and       	type >= 0 and type < kItemLen       then begin       	if (if kBuild20 then IsInteger(options) else isInstance(options, 'int))       	then options := :getConfigOptions(options, host, zone, caller);              	if not isArray(options)       	then return NIL;              	local IR := type = kSlowIRitem or type = kSerialIRitem or type = kIrDAitem;       	local epErr, address;              	local ep := {       		_proto:  protoSerialProtocol,       		configOptions: 	options,       		remoteAddress: 	if kAll and host       			then address :=       				if kNewEndpoint       				then MakeAppleTalkOption(host & ":ADSP@" & if zone then zone else $*)       				else {       					type: 'address,       					label: kCMARouteLabel,       					opCode: opSetRequired,       					data: {       						addressType: kNamedAppleTalkAddress,       						addressData: host & ":ADSP@" & if zone then zone else $*,       						},       					},       		receiveFlags:	if kAll and IR then kFrame, 	// !!!a =kSlowIRitem ??       		// !!!a or recvFlags in each: waitForChar, waitForSoupName, waitForEntrySpec, waitForEntries ???       		_parent: caller,	// !!!a       		sloupType: type,       		};              	local gData;       	if kBuild20 and (gData := GetGlobalVar(kNewtsCapeSymbol)) and	// !!!d       		gData.protos and (gData := gData.protos.NTE_protoBasicEndPoint)       	then begin       		ep._proto := Clone(protoSerialProtocol);              	ep._proto._proto := gData;		// replace protoBasicEndpoint with NTE_protoBasicEndPoint              	ep.NTEncoding := {       			prefs: GetAppPrefs(kAppSymbol, {}).NTEncoding,       			defaultEncoding: kDefaultEncoding,       			};       		end;              	caller:setStatus(LocObj("Instantiating", 'instantiateEP));       	if kNewEndPoint       	then begin       		try ep:Instantiate(ep, options)              	onexception |evt.ex.comm|              	do epErr := CurrentException().error;       		end       	else begin       		if kAll and type=kADSPitem // or type = kSlowIRitem)	// !!!a ADSP??       		then ActiveConnection := ActiveListenConnection := 0;       		epErr := ep:Instantiate(ep, options);        		end;              	if epErr       	then caller:errorStatus(LocObj("Instantiate Error", 'instantiateErr) & $: && epErr)       	else if kNewEndPoint       	then begin       		caller:setStatus(LocObj("binding", 'binding));       		try ep:Bind([], nil)              	onexception |evt.ex.comm|       		do caller:errorStatus(LocObj("Bind Error", 'bindErr) & $: && epErr := CurrentException().error);              	end;              	if not epErr       	then begin       		caller:setStatus(LocObj("connecting", 'connecting));       		if kNewEndPoint       		then begin       			try if IR              			then ep:Listen(nil, nil)              			else ep:Connect([address], nil);               	onexception |evt.ex.comm|       			do caller:errorStatus(LocObj("Connect Error", 'connectErr) & $: && epErr := CurrentException().error);              			if IR and not epErr       			then try ep:Accept(nil, nil)       				onexception |evt.ex.comm|       				do caller:errorStatus(LocObj("Accept Error", 'acceptErr) & $: && epErr := CurrentException().error);       			end              		else begin       			if kAll and kBuild1x and type=kSerialIRitem       			then call kEnableIRModuleFunc with (true);       			if epErr := if kAll and IR then ep:Listen(nil) else ep:Connect(address, nil)       			then caller:errorStatus(LocObj("Connect Error", 'connectErr) & $: && epErr);       			end;       		end;              	if epErr       	then return ep:disconnectComplete();	// NIL              	ep:SetInputSpec(ep.firstLineSpec);       	ep.inspReset := GetRoot().(kNewtSymbol):?setInspector(ep,nil);       	ep;       end,     closeEndpoint:       func(ep, caller)	// !!!a. called by 'app', epDisconnect       if ep       then begin       	GetRoot().(kNewtSymbol):?setInspector(NIL, ep.inspReset);              	caller:setStatus(kDisconnecting);       	if kNewEndPoint       	then begin              	/* // Cancel,Disconnect done initially in disconnectComplete anyway              	try ep:Cancel(nil)              	onexception |evt.ex.comm|       		do nil;              	              	try ep:Disconnect(nil, nil)       		onexception |evt.ex.comm|       		do caller:errorStatus(kDisconnecting & $: && CurrentException().error);       		*/              		AddDeferredSend(ep, 'disconnectComplete, nil); // delay?       		end              	else begin       		ep:FlushInput();       		ep.nextInputSpec := NIL;       		ep:SetInputSpec(nil);       		ep:Abort();              		AddDelayedAction(Functions.Perform,       			[ep,'disconnectComplete,'[]], kAbortDelay);       		end;              	//caller:setStatus(kDisconnected);		// in disconnectComplete       	NIL;       	end,     entryString: eString,     viewJustify: 0,     addIndexes:       func(s,add) // option: addIndexes at end (instead of beginning)       begin       	s := TrimString(s);       //Print(s);       	local spos := if kBuild20 then CharPos(s,$!,0) else StrPos(s,kExcl,0), aindex, index, slen := StrLen(s), slist;       	if spos and spos < slen-1       	then aindex :=       			try call Compile(Substr(s,spos+1,nil)) with ()             	onexception |evt.ex|       			do NIL;              // if soup had indexes, we would have to be much more careful       // then iterate over individual soups, testing whether index already existed       	if add and isArray(aindex) and targetSoup and       		isArray(slist := if kBuild20 or nos20       			then targetSoup:GetSoupList()       			else targetSoup.soupList) and       		Length(slist) > 0 and       		Length(slist[0]:getIndexes())=0       	then begin       		if Visible(sloup)       		then begin       			:setStatus(LocObj("adding indexes", 'addingIndexes));       			SetValue(numIndexes, 'text, SPrintObject(Length(aindex)));       			RefreshViews();       			end;              		foreach index in aindex       		do targetSoup:addIndex(index);       		end;       	aindex; // so newSoup can add via RegisterCardSoup       end,     Newline:       func(s)       begin       //Print("newline:" && s);       	local result, status;              	//if BeginsWith(s,lf) then	// replace all anyway       	//StrReplace(s,lf,"",nil);	// replace LFs, esp. initial if any              	:fixString(s,sloupSpec.translationTable,sloupSpec.convertUnicode);              	if notes and entrySpec // Notes?       	then if BeginsWith(s,endOfPara)       		then result := entryPara       		else begin       			if nos20 and (entrySpec.class='list or entrySpec.class='checkList)       			then if entryPara       				then AddArraySlot(entryPara,s)       				else begin       					entryPara := [s];       					status := LocObj("paragraph", 'paragraphMsg) & $: && s;       					end              			else if entryPara       			then :myStrMunger(entryPara,nil,0,s,0,nil)       			else status := LocObj("paragraph", 'paragraphMsg) & $: && entryPara := s;       			end              	else begin       		local slen := StrLen(s);       		local cont := EndsWith(s, "\\\n");       		if longStr       		then begin       //Write("cont: "); Print(cont); Print(s);       			if cont       			then begin       				// first line       				entryPara := SubStr(s, 0, slen-2);	// skip \ and cr       				entryBinary := if kBuild20       					then begin       						sloup.nextFlush := kVBOFlush;	// !!! if used externally & sloup doesn't exist?       						call kNewVBO with (nil, nil, "");       						end       					else Clone("");       				end              			else if BeginsWith(s, endOfPara)       			then result := entryPara	// last line              			else :myStrMunger(entryBinary, nil, 0, s, 0, nil)       				//StrMunger(entryBinary, StrLen(entryBinary), 0, s, 0, nil) // include cr       			end       		else if slen > 1       		then begin // non-empty data line (including cr)       			if cont or entryPara       			then begin // either line continuation or finish para/binary       				if not entryPara       				then begin       					entryPara := Clone("");       					entryBinary := NIL;       					end;       				if entryBinary       				then begin       					:Ustring(entryBinary, s, 0, if cont then slen-2 else slen-1, nil);       					if kBuild20 and Length(entryBinary) > nextFlush       					then begin       						if isVBO(entryBinary)       						then ClearVBOCache(entryBinary);       						nextFlush := nextFlush + kVBOFlush;       						end;       					status := SubStr(entryPara,0,18) && "[len(binary):" && Length(entryBinary) & $];       					end       				else begin       					//StrMunger(entryPara, StrLen(entryPara), 0,       					:myStrMunger(entryPara, nil, 0,       								s,0,if cont then slen-2 else slen);       					if entrySpec and EndsWith(entryPara, kBinaryStart)       					then entryBinary :=       						if kBuild20       						then begin       							sloup.nextFlush := kVBOFlush;       							call kNewVBO with (nil, 'binary, 0);       							end       						else SetLength(Clone(""), 0);       					if entrySpec then status := SubStr(entryPara,0,18) && "[len:" && StrLen(entryPara) & $];       					end;       				result := if not cont then entryPara;       				end       			else if StrFilled(TrimString(s))	// note: this removes cr & trailing tabs from single line!       			then result := s;       			end;       	end;              	if Visible(sloup)       	then begin       		:setStatus(status);       		:setEntry(s);       		if prefsCurrent.refresh       		then RefreshViews();       		end;              	if kBuild20 and result       	then begin       		if isVBO(entryPara)       		then ClearVBOCache(entryPara);       		if isVBO(entryBinary)       		then ClearVBOCache(entryBinary);       		end;              	result;       end,     title: kVersion,     numLines: 0,     powerOffScript:       func(what)       what = 'okToPowerOff and not commEndPt,     connectionLabels:       func(basic)		// !!!a       if (if kNewEndpoint then basic else not basic)       then kConnLabels,     Ustring:       func NATIVE (b, s, INT sstart, stop, cl)       if s[sstart]=$!       then begin       	SetClass(entryBinary,cl); // from native code, returns #! rather than obj       	entryBinary;       	end              else begin       //Print(s);       	local ARRAY cc := '[0,1,2,3,4,5,6,7,8,9,58,59,60,61,62,63,64,10,11,12,13,14,15]; // 0-F (with a gap)       	local INT i, s1, s2, cc1, cc2, bstart := 0, cclen := Length(cc);       	local kOrd := Functions.Ord;       	local INT sstop := if stop       		then stop       		else call Functions.StrLen with(s) -1; // assume CR              // s needs to be converted to unicode       // instead of creating another binary (or destroying this string)       // and then using BinaryMunger, just add directly       	if b       	then bstart := Length(b)       	else b := Clone(eString);       	SetLength(b, bstart + (sstop-sstart) div 2);              	for i := sstart to sstop-1 by 2       	do begin       		s1 := call kOrd with(s[i])   -zeroChar;       		if s1 >= cclen then s1 := s1-32; // lower-> uppercase       		cc1:= cc[s1];       		s2 := call kOrd with(s[i+1]) -zeroChar;       		if s2 >= cclen then s2 := s2-32;       		cc2:= cc[s2];       		StuffByte(b, bstart, (cc1 << 4) + cc2);       		bstart := bstart+1;       		end;       	if cl then SetClass(b,cl);       	b;       	end,     commEndPt: nil,     entrySpecFunc:       nil // set to a method later       ,     buildEntrySpec:       /* BuildEntrySpec       	Compile a WallyScript frame definition and get the resulting object.              	Slots used:       		entrySpec, entrySpecFunc       */       func(s)       begin //  Compile a frame definition and get the resulting object.       	local err;       	entryPara := entryBinary := NIL;       	try entrySpecFunc := Compile(s)       	onexception |evt.ex|       	do err := LocObj("compile", 'compileMsg);              	if not err       	then try entrySpec := :entrySpecFunc();       		onexception |evt.ex|       		do err := LocObj("evaluate", 'evaluateMsg);              	if err or not isFrame(entrySpec)       	then begin       		:setStatus(       			(if err then err else LocObj("not a frame", 'notFrameErr))       			&& LocObj("Entry spec invalid", 'invalidEntrySpec) & "!."       			&& kWaitingSoup);       		entrySpec := NIL;       		end              	else if StrEqual(targetSoupName,kSloup) or StrEqual(targetSoupName,kSlurpee)       	then begin       		entrySpec._proto := sloup._proto.sloupSpec;       		sloupSpec := entrySpec;       		:setStatus(LocObj("Sloup settings done", 'sloupSetDone) & $. && kWaitingSoup);       		sloupedGauge:?close();       		entrySpec := NIL; // wait for soup       		end              	else begin       		local val, lastVal;       		foreach val in entrySpec       		do lastVal := val;       		longStr := (if kBuild20 then IsString(lastVal) else isInstance(lastVal, 'string)) and       					StrEqual(lastVal, kLongStr);              		:setStatus(kWaitingEntries);       		if sloupSpec.totalRecords       		then sloupedGauge:?open()       		else sloupedGauge:?close();       		entrySpec       		end;       end,     setNumEntries:       func(num)       if Visible(sloup)       then begin       	numEntries := num;       	SetValue(entriesSlouped, 'text,       		if sloupSpec.totalRecords       		then num & $/ & sloupSpec.totalRecords       		else SPrintObject(num));       	if Visible(sloupedGauge)       	then SetValue(sloupedGauge, 'viewValue, num);       	end,     epConnect:       func()	// !!!a       if not commEndPt and       	commEndPt := sloup:openEndpoint(configOptions, prefsCurrent.host, prefsCurrent.zone, sloup, sloupType)       then sloup:restartConn()       	/* !!!f.       	begin       	sloup:restartConn();       	if connButton       	then SetValue(connButton, 'text, kDisconnect);       	connStatus:?update();       	end*/,     viewSetupFormScript:       func()       begin       	local ap := GetAppParams(); // bounds of current screen       	local INT aWid := ap.AppAreaWidth, aHt := ap.AppAreaHeight;       	if aWid < kAppWidth or aHt < kAppHeight // screen too small       	then begin       		:Notify(kNotifyAlert, title, LocObj("Screen smaller than", 'screenSmaller) && kAppWidth & $x & kAppHeight);       		return self:close();       		end;              	self.nos20 := kBuild20 or Functions.GetAppPrefs exists;       	if not reorienting       	then begin       		if kBuild20 or nos20       		then prefsEntry := GetAppPrefs(kAppSymbol, {})       		else begin       			local sysSoup := GetStores()[0]:GetSoup(sysSoupName);       			if not (prefsEntry := :getEntry(sysSoup,'tag,kPackageName))       			then prefsEntry := sysSoup:Add({tag: kPackageName});       			end;       		prefsCurrent := Clone(prefsEntry);       		prefsCurrent._proto := self._proto.prefsCurrent;       		end;              	local insp := prefsCurrent.inspect;       	viewBounds := Clone(_proto.viewBounds);       	viewBounds.bottom := viewBounds.top +       		(if insp then kInspHeight else kAppHeight);       	viewBounds.right := viewBounds.left +       		(if insp then kInspWidth  else kAppWidth);       end,     getConfigOptions:       DefineGlobalConstant('kBPSpath,       if kNewEndpoint       then '[pathExpr: 1,data,arglist,3]       else '[pathExpr: 1,data,bps]       );       				       func(INT cmd, host, zone, caller)	// !!!a       begin       	local ARRAY options := protoSerialProtocol.configOptions;       	local connOptions := bpsOptions[cmd]; // just speed for serial, or replace configOptions entirely              	if kAll and cmd = kADSPitem       	then if host       		then connOptions       		else begin       			local args := [nil, "=:ADSP@", nil, caller, LocObj("Choose", 'ChooseMsg),       				LocObj("ADSP", 'ADSPlabel), LocObj("ADSPs", 'ADSPslabel)];       			if kBuild20 or nos20 // since epDisconnect may still be pending       			then AddDelayedSend(GetRoot().netChooser,'openNetChooser, args, kAbortDelay)       			else AddDelayedAction(Functions.Perform, // !!!a       					[GetRoot().netChooser, 'openNetChooser, args], kAbortDelay);       			NIL;       			end              	else if kAll and (cmd = kMNPitem)       	then connOptions              	else if kAll and (cmd = kSlowIRitem or cmd = kSerialIRitem or cmd = kIrDAitem)	// !!!a       	then if cmd = kSerialIRitem       		then begin       			if kNewEndPoint       			then begin       				AddArraySlot(       					options := call kSetClone with (options, kBPSpath, bpsOptions[1]),	// 19200       					connOptions);       				call kSetClone with (options, '[pathExpr: 2,data,arglist,2], nil); // turn off xon/xoff       				call kSetClone with (options, '[pathExpr: 3,data,arglist,2], nil); // turn off xon/xoff       				end       			else AddArraySlot(       					options := Clone(options),       					{	// kGetSCCSideBFunc dynamically here (rather than in bpsOptions)       					label:	kCMOSerialHardware, 	//"scc "       					type:	'option,       					opCode:	opSetRequired,			//0x0200       					data:	call kGetSCCSideBFunc with (),	// bus error for 2.x deprecated version!       					});       			options;       			end       		else connOptions	// slowIR, IrDA              	else begin       		if kNewEndPoint or (kAll and cmd > 0)       		then begin       			options := if cmd=0       				then Clone(options)	// default: 9600 bps       				else call kSetClone with (options, kBPSpath, connOptions); // replace just bps       			if kNewEndPoint       			then AddArraySlot(options, bpsOptions[0]);       			end;       		options;       		end;       end,     longStr: nil,     prefsEntry: nil,     viewClickScript:       func(unit) // 1.x       self=sloup       and ABS(GetPoint(firstY, unit) - :GlobalBox().top) <= kDragRadius       and ABS(GetPoint(firstX, unit) - :GlobalBox().left - ((viewBounds.right - viewBounds.left) div 2)) <= kDragRadius       and :Drag(unit, nil)   // returns TRUE       ,     readEvalPrint:       func(s)       begin       	local val;       	:print(s);       	:print(       		try val := call compile(s) with ()       		onexception |evt.ex|       		do begin       			if prefsCurrent.soundSym then PlaySound(kErrSound);       			local err := currentException();       			kError && err.name &&       				if err.error       				then err.error       				else if err.data       				then err.data.errorCode;       			end);       	val;       end,     setReplaceslot:       func(s)       begin       	local INT spos := if kBuild20 then CharPos(s,$!,0) + 1 else StrPos(s,kExcl,0) + 1;       	replaceSlot := Intern(TrimString(SubStr(s,spos,nil)));       end,     entryIndex: nil,     numEntries: nil,     dumpEntrySpec:       func(fr)       begin       	local s,v, res := {};       	if isArray(fr)       	then begin       		res := Array(Length(fr),nil);       		SetClass(res,ClassOf(fr));       		end;       	foreach s,v in fr       	do res.(s) :=       		if isArray(v) or isFrame(v)       		then :dumpEntrySpec(v)       		else if v       		then SPrintObject(ClassOf(v))       		else "symbol";       	res;       end,     fixString:       func(str, translationTable, convertUnicode)       begin       	local INT slen := StrLen(str), i, ulen;       	if isArray(translationTable) and slen > 0       	then for i:=0 to Length(translationTable)-1 by 2       		do StrReplace(str,translationTable[i],translationTable[i+1],nil); // fixCR??              	local spos, epos := 0, ustr, cpos := if kBuild20 then CharPos(str,unicodeCR,0) else StrPos(str,cr,0);       	local ARRAY cc := '[0,1,2,3,4,5,6,7,8,9,58,59,60,61,62,63,64,10,11,12,13,14,15]; // 0-F (with a gap)       	if convertUnicode       	then while spos := StrPos(str, unicodeStart, epos)       		do begin       			epos := StrPos(str, unicodeStart, spos+1);       			ulen := (if epos       						then epos       						else if cpos       						then cpos := if kBuild20 then CharPos(str,unicodeCR,spos) else StrPos(str,cr,spos) // recalc       						else StrLen(str)) - (spos+2);       			ustr := Upcase(SubStr(str,spos+2,ulen));       			for i:=0 to ulen-1 by 4       			do ustr[i div 4] :=       				Chr(       					cc[Ord(ustr[i])   -zeroChar] << 12 +       					cc[Ord(ustr[i+1]) -zeroChar] <<  8 +       					cc[Ord(ustr[i+2]) -zeroChar] <<  4 +       					cc[Ord(ustr[i+3]) -zeroChar]       					);       			:myStrMunger(str, spos, (if epos then epos+2 else if cpos then cpos else StrLen(str)) - spos,       						ustr, 0, ulen div 4);       			epos := spos + (ulen div 4);       		end;       	str;       end,     sloupSpec:       {totalRecords: 	NIL,       fieldDelimiter: tab,       stripQuotes: 	NIL,       translationTable: NIL,       convertUnicode:	NIL,              debug:	 		NIL,       clearKey: 		"\u001B",	// clear       evalKey: 		"\u001A", 	// ctrl-z,       enterKey:		"\u0003", 	// ctrl-c       closeKey: 		"\u0017",	// ctrl-w       scrollUpKey: 	"\u001E",	// ctrl-^       scrollDownKey: 	"\u001F",	// ctrl-v              keyboardMap:	[],       },     buildEntry:       func (currentFrameOrArray,top)       /* BuildEntry       	Convert a tab delimited string of data into a soup entry (ie. frame)              	Methods used:       		matchTypes, nextInputString       	       	Assumptions:       		currentFrameOrArray parameter is initialized to a frame.       */       begin       	local path, value, pClass;              	// For each slot in the frame or each element in the array.       	// The cool thing about foreach is that it doesn't care.  By       	// using the path foreach creates, we can even assign values       	// with the exact same code...              	foreach path, value in currentFrameOrArray       	do begin       		// Get the real class of the first slot/element.  In the       		// case of the "Names" soup, the frame containing the       		// person's name has a class slot set to 'person.  Because       		// of this, the ClassOf function returns 'person instead       		// of 'frame.  Using PrimClassOf (ie. Prim(itive)ClassOf)       		// we can find out the real type.       		pClass := PrimClassOf(value);              		// Since frames/arrays can contain other frames/arrays,       		// we can use recursion to simplify the function.  If       		// we run across an element that is a frame/array, we       		// just call ourself with the new path.  We Clone the       		// spec value to reduce garbage collection and prevent       		// having separate code for creating frames and arrays.              		if pClass = 'frame or pClass = 'array // isArray, isFrame?       		then :BuildEntry(currentFrameOrArray.(path) := Clone(value),NIL)              		// Finally the real work.  If the slot value is not a       		// frame/array, assign the new value.  getNextField       		// returns the next tab-delimited string from the input       		// buffer.  matchTypes is used to coerce the string       		// into the type specified by value.       		// NOTE        		//	We pass value instead of ClassOf(value) because       		//	some types are specified using the contents of       		//	a string.  See matchTypes for more info...              		else currentFrameOrArray.(path) :=       				if (if kBuild20 then IsString(value) else isInstance(value,'string)) and       					((if kBuild20       					then  LSearch(kBinaryTypes, value, 0,'|str=|,nil)       					else ArrayPos(kBinaryTypes, value, 0, Functions.StrEqual))       					or (entryBinary and value and BeginsWith(value, kBinaryPrefix)       							and value := SubStr(value,7,nil)))       				then (if value := :BuildBinary(value) then value else RETURN NIL) // mask       				else :matchTypes(:nextInputString(), value);        		end;              	// if very last item is array, allow it to be variable length (using last type)       	if top and pclass='array       	then begin       		value := value[Length(value)-1];       		local INT slen := StrLen(entryString);       		while entryIndex < slen       		do AddArraySlot(currentFrameOrArray.(path), :matchTypes(:nextInputString(), value));       		end;       	currentFrameOrArray;       end,     matchTypes:       func NATIVE (valueString, valueType)       /* matchTypes       	Coerce the type of a value to match another.                	Assumptions:          The type specified by valueType is never Frame or Array.          If the type is string, then the real type is specified          as a symbol stored within that string.  For example,             "string"   Coerce the value to type string             "date"     Coerce the value into a date value          If the string is specified as:             "stringWithClass"          then the valueString is made into a symbol, and the          type of the string becomes that symbol (ie. name, company).        */       begin       	if valueType='string       	then valueType := "string";       	local theType := ClassOf(valueType), cpos, val;       	local INT i, vlen := StrLen(valueString);                 // If valueType is string, get real type from string contents.          if theType = 'string       	then if StrEqual(valueType, kClassString)       		then (if cpos := if kBuild20 then CharPos(valueString, $:, 0) else StrPos(valueString,kColon,0)       			then begin       				i := cpos;       				theType := Intern(SubStr(valueString,0,i));       				valueString := SubStr(valueString,i+1, vlen-i-1);       				end) // otherwise, leave theType, valueString alone       		else if (kBuild20 or nos20) and StrEqual(valueType, kLongStr)       		then return entryBinary       		else theType := Intern(valueType);              	if theType = 'string       	then valueString              	else if theType = 'int       	then if val := StringToNumber(valueString)       		then Floor(val)       		else 0              	else if theType = 'real       	then begin       		local loc := GetLocale().numberFormat.decimalPoint;       		if (if kBuild20 then CharPos(valueString,$.,0) else StrPos(valueString,kDecimal,0)) and       			not StrEqual(loc,kDecimal)       		then StrReplace(valueString,kDecimal,loc,nil);       		if val := StringToNumber(valueString)       		then val       		else 0.0;       		end              	else if theType = 'symbol or theType = 'boolean or       			theType = 'stringWithClass  // for Names       	then if vlen=0 or StrEqual(valueString,"nil")       		then nil       		else if StrEqual(valueString,"true")       		then true       		else Intern(valueString)              	else if theType='date or theType='dateTime or theType='dateXLS       	then StringToDate(valueString)              	else if theType = 'para // e.g. for adding single para to Card Notes       	then {viewStationery: 'para,       			viewBounds: {left: 4, top: 0, right: 240, bottom: 100},       			text: valueString,       			viewFont: userFont12,       			}              	//else if theType = 'bitmap // etc. handled beforehand in buildEntry       	//then :makeBitMap(valueString,newEntry.width)                 else if vlen > 0       	then begin       		SetClass(valueString, theType);       		valueString; // in native, setClass returns #!       		end;       end,     notes: nil,     getEntry:       func(soup, idxSlot, key) // get existing soup entry (for REPLACE! or bitmap!)       begin       	local ispec := {       		type: 'index,       		indexPath: idxSlot,       		startKey: key,       		}, curkey;       	local entry :=       		if kBuild20       		then soup:Query(ispec):entry()	// gotoKey(key)?       		else Query(soup,ispec):entry();              	if entry and (curkey := entry.(idxSlot)) and       		(key = curkey or  // doublecheck       			(if (if kBuild20 then IsString(key) else isInstance(key,'string))       			then StrEqual(key,curkey)))       	then entry;       end,     nos20: nil,     reorienting: nil,     targetSoupName: nil,     entryPara: nil,     viewShowScript:       func() // !!!g       if kBuild20 and self.hideObj       then begin       	GetRoot().notifyIcon:?KillAction(hideObj);	       	hideObj := NIL;       	end,     eraseEntries:       func()       if targetSoup       then begin       	local elabel := entrySpec.labels;       	local nolabel := not HasSlot(entrySpec,'labels) or elabel = '_all;       	local eclass := entrySpec.class; // for Notes (primarily)       	:setStatus(ParamStr(LocObj("Erasing (^0) entries in ^1", 'eraseEntries),       			[if nolabel then LocObj("All", 'allFolders)       			else if elabel then SPrintObject(elabel)       			else LocObj("Unfiled", 'unfiledFolder),       			targetSoupName]));       	RefreshViews();              	local cursor :=  // can't index on labels       		if kBuild20 or nos20       		then targetSoup:Query(nil)       		else Query(targetSoup,kDefaultIndex);       //soup:RemoveAllEntries (for nolabel) doesn't seem to work, so do it the old fashioned way       	local entry := cursor:entry();       	while entry       	do begin       		if (nolabel or call kLabelEqual with (elabel, entry.labels)) and       			(not eclass or eclass = entry.class)       		then if kBuild20 or nos20       			then EntryRemoveFromSoupXmit(entry, nil)       			else EntryRemoveFromSoup(entry);        		entry := cursor:next();       		end;       	//BroadcastSoupChange(targetSoupName); // do at BYE time       	:setStatus(kWaitingEntries);       	end,     restartConn:       func()       begin       if kProfileOn and profilingOn       then EnableProfiling(profilingOn := NIL);              	if isFrame(targetSoup) // see end of epDisconnect       	then call kMyUnRegCardSoup with (targetSoupName,0);              	targetSoup := notes := entrySpec := entryString := entryPara := entryBinary := NIL;              	if commEndPt	// !!!a       	then begin       		local spec, firstSpecs;       		if not commEndPt.firstLine and isReadonly(firstSpecs := commEndPt.otherSpecs)       		then commEndPt.otherSpecs := firstSpecs := Clone(firstSpecs);              		if prefsCurrent.inspect       		then if commEndPt.firstLine       			then spec := commEndPt.waitForChar       			else begin       				firstSpecs[0] := 'waitForChar;       				firstSpecs[1] := 'waitForSoupName;       				end              		else begin       			if commEndPt.firstLine       			then spec := commEndPt.waitForSoupName       			else begin       				firstSpecs[0] := 'waitForSoupName;       				firstSpecs[1] := 'waitForChar;       				end;       			:setStatus(kWaitingSoup);       			end;              		if spec       		then begin       //Print(spec);       			if kNewEndpoint       			then begin       				try commEndPt:Cancel(nil)       					/*{async: true,       					completionScript: func(ep, options, result)       					begin       						ep:SetInputSpec(spec);       					end,       					})*/       				onexception |evt.ex.comm|       				do nil;       //Print("after cancel");       				Sleep(kOutputDelay);       				end;       //Print("before spec");       			commEndPt:SetInputSpec(spec);       //Print("after spec");       			end;       		end;              	if prefsCurrent.soundSym       	then PlaySound(if kBuild20       		then GetRegisteredSound(prefsCurrent.soundSym)       		else ROM_soundoff.(prefsCurrent.soundSym));       end,     BitsToString:       func(bits, INT offset)       // from a bitmap/sound, generate an ascii string print representation        begin       	local ch, s := "!\\" & crlf;       	local INT i, last := Length(bits)-1;       	for i := offset to last       	do begin       		ch := ExtractByte(bits, i);       		s := s & kHex[Band(ch >> 4, 0xF)] & kHex[Band(ch, 0xF)];       		if ((i+1) mod 36)=0 and i < last  // flush every 72 chars or so       		then begin       			call kOutputStr with (commEndPt, s & $\\ & crlf);       			s := "";       			end;       		end;       	call kOutputStr with (commEndPt, s);       	NIL;       end,     replaceSlot: nil,     dumpNoteExtra:       func(espec, entry, sfun, fieldSep, first, nameSep)       begin       	// dump any other fields (labels, _modTime,...)       	local obj := Clone(espec);       	RemoveSlot(obj,'title);       	RemoveSlot(obj,'class);       	:dumpEntryString(obj, entry, sfun, fieldSep, nil, nameSep);	// !!!i       	       	if espec.title and ((obj := entry.data) or (obj := entry.topics))       		and Length(obj) > 0 and       		(text := obj[0].text) and       		(if kBuild20 then IsString(text) else isInstance(text, 'string))       	then begin       		text := if entry.title       			then entry.title       			else SubStr(text, 0, if kBuild20 then CharPos(text, unicodeCR, 0) else StrPos(text, cr, 0));       		:setEntry(text); // display title       		if nameSep then text := 'title & nameSep & text;	// !!!i       		call kOutputStr with (commEndPt, text & fieldSep);       		end;       end,     SetStatus:       func(txt)       if statusBox and txt       then SetValue(statusBox, 'text, txt)    };registerButton :=    {viewBounds: {left: 171, top: 33, right: 186, bottom: 45},     buttonClickScript:       func()       begin       	local RegView := GetRoot().(kRegistrationPackage);       	RegView:open();       	RegView:ExternalRegister(kRegFrame);       end,     icon:       MakePixFamily(           GetResourceFromFile({filename: "SW:Newton:Sloup 2.2:Sloup.rsrc",                 resource: 132}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: "SW:Newton:Sloup 2.2:Sloup.rsrc",                   resource: 132}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":\u000A000A001F\ur\u221E",                   resource: }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":\u000A000A001F\ur\u221E",                   resource: }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":\u000A000A001F\ur\u221E",                   resource: }),             bitDepth: 8}]);,     viewSetupFormScript:       func()       begin       	registerButton := self;       	inherited:?viewSetupFormScript();       end,     _proto: @198 /* protoPictureButton */    };AddStepForm(sloupBaseView, registerButton);pasteButton :=    {     buttonClickScript:       func() // paste current text entry or highlighted selection (if any)       begin       	//if kAll and IR 				// !!!a       	//then commEndPt:SetInputSpec(nil);       	       	:print(:getSelection(GetView('viewFrontKey)));              /*       	if kAll and IR				// !!!a       	then commEndPt:SetInputSpec(       			if prefsCurrent.inspect       			then commEndPt.waitForChar       			else commEndPt.waitForSoupName);       */       end       ,     text: "Paste",     viewBounds: {left: 3, top: 1, right: 47, bottom: 11},     _proto: @226 /* protoTextButton */    };AddStepForm(sloupBaseView, pasteButton);// After Script for pasteButtonthisView := pasteButton;begin	thisView.text := LocObj("Paste", 'pasteLabel);endconnPicker :=    {viewBounds: {left: 0, top: 14, right: 100, bottom: 26},     labelCommands:       [kDisconnected, "Keyboard", "Command"]	// LocObj???       ,     alwaysCallPickActionScript: true,     pickerSetup:       func()       begin       	labelCommands[0] := if commEndPt then kDisconnect else kDisconnected;       	true;       end,     viewSetupFormScript:       func()       begin       	labelCommands := Clone(labelCommands);	// for modif in pickerSetup       	inherited:?viewSetupFormScript();       end,     labelActionScript:       func(cmd)       if cmd=0       then begin	// Connect/Disconnect       	if commEndPt       	then :epDisconnect();       	// else already disconnected       	end              else begin	// Keyboard/Command       	local changed := prefsCurrent.inspect <> (cmd=1);       	if changed       	then begin       		:setPreference('inspect, cmd=1);       		SetValue(sloup, 'viewBounds, sloup.viewBounds); // viewSetupFormScript will adjust       		end;       	if cmd=1 then :updateText("Kbd");	// !!!g              	if commEndPt       	then begin       		if changed       		then begin       			if prefsCurrent.soundSym then PlaySound(if cmd=1 then ROM_drawerclose else ROM_draweropen);       			:restartConn();       			end;       		// else already connected       		end       	else :epConnect();       	end,     indent: 12,     textSetup:       func()	// !!!g       if commEndPt       then if prefsCurrent.inspect       	then "Kbd"       	else labelCommands[2]       else labelCommands[0],     _proto: @190 /* protoLabelPicker */    };AddStepForm(sloupBaseView, connPicker);StepDeclare(sloupBaseView, connPicker, 'connPicker);// After Script for connPickerthisView := connPicker;beginif kBuild1xthen RemoveSlot(thisView, 'alwaysCallPickActionScript);endsloupTitle :=    {viewBounds: {left: 59, top: 2, right: 139, bottom: 15},     viewJustify: 8388614,     viewFormat: 50331653,     viewTransferMode: 3,     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, sloupTitle);// After Script for sloupTitlethisView := sloupTitle;begin	thisView.text := kVersion;	if StrLen(kBetaVersion) = 0	then begin		thisView.viewBounds.left  := thisView.viewBounds.left+3;		thisView.viewBounds.right := thisView.viewBounds.right-3;		end;endnewtButton :=    {viewBounds: {left: 88, top: 18, right: 120, bottom: 47},     buttonClickScript: func() GetRoot().(kNewtSymbol):?open(),     icon:       MakePixFamily(           GetResourceFromFile({filename: "SW:Newton:Sloup 2.2:Sloup.rsrc",                 resource: 128}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename: "SW:Newton:Sloup 2.2:Sloup.rsrc",                   resource: 128}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":\u000A000A001F\ur\u221E",                   resource: }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":\u000A000A001F\ur\u221E",                   resource: }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":\u000A000A001F\ur\u221E",                   resource: }),             bitDepth: 8}]);,     viewFormat: 67109377,     _proto: @198 /* protoPictureButton */    };AddStepForm(sloupBaseView, newtButton);StepDeclare(sloupBaseView, newtButton, 'newtButton);bpsPicker :=    {viewBounds: {left: 142, top: 0, right: 206, bottom: 12},     labelActionScript:       func(cmd)       begin       	:setPreference('bps, cmd);	// !!a. moved from initConfig       	:initConfig(cmd);       end,     textSetup:       func()       if kAll then labelCommands[min(prefsCurrent.bps, Length(labelCommands)-1)] else labelCommands[0]     ,     alwaysCallPickActionScript: true,     indent: 12,     _proto: @190 /* protoLabelPicker */    };AddStepForm(sloupBaseView, bpsPicker);// After Script for bpsPickerthisView := bpsPicker;begin	thisView.labelCommands := kConnLabels;	if kBuild1x	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endinfoButton :=    {DoInfoAbout: func() AboutView:open(),     viewJustify: 6,     viewBounds: {left: 192, top: 33, right: 205, bottom: 46},     _proto: _v76_0    };AddStepForm(sloupBaseView, infoButton);// After Script for infoButtonthisView := infoButton;if kBuild20then thisView._proto := protoInfoButtonelse call kFixupInfoItems with (thisView)statusLabel :=    {text: "Status:",     viewBounds: {left: 2, top: 41, right: 53, bottom: 53},     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, statusLabel);StepDeclare(sloupBaseView, statusLabel, 'statusLabel);// After Script for statusLabelthisView := statusLabel;begin	thisView.text := LocObj("Status", 'statusLabel) & $:;endstatusBox :=    {viewBounds: {left: 2, top: 53, right: 206, bottom: 81},     viewFlags: 35,     viewFont: simpleFont9,     viewFormat: 337,     viewLineSpacing: 13,     viewClass: 81 /* clParagraphView */    };AddStepForm(sloupBaseView, statusBox);StepDeclare(sloupBaseView, statusBox, 'statusBox);soupLabel :=    {text: "Soup:",     viewBounds: {left: 2, top: 85, right: 31, bottom: 97},     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, soupLabel);// After Script for soupLabelthisView := soupLabel;begin	thisView.text := LocObj("Soup", 'soupLabel) & $:;endsoupNameDisplay :=    {viewBounds: {left: 33, top: 85, right: 104, bottom: 97},     viewFont: simpleFont9,     viewFormat: 337,     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, soupNameDisplay);StepDeclare(sloupBaseView, soupNameDisplay, 'soupNameDisplay);// After Script for soupNameDisplaythisView := soupNameDisplay;thisView.text := eStringentriesSloupLabel :=    {text: "Entries:",     viewBounds: {left: 109, top: 85, right: 156, bottom: 97},     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, entriesSloupLabel);// After Script for entriesSloupLabelthisView := entriesSloupLabel;begin	thisView.text := LocObj("Entries", 'entriesLabel) & $:;endentriesSlouped :=    {text: 0,     viewBounds: {left: 158, top: 85, right: 206, bottom: 97},     viewFont: simpleFont9,     viewFormat: 337,     viewJustify: 8388609,     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, entriesSlouped);StepDeclare(sloupBaseView, entriesSlouped, 'entriesSlouped);indexLabel :=    {text: "Indexes:",     viewBounds: {left: 46, top: 99, right: 92, bottom: 111},     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, indexLabel);// After Script for indexLabelthisView := indexLabel;begin	thisView.text := LocObj("Indexes", 'indexLabel) & $:;endnumIndexes :=    {text: 0,     viewBounds: {left: 88, top: 100, right: 104, bottom: 112},     viewFont: simpleFont9,     viewFormat: 337,     viewJustify: 8388609,     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, numIndexes);StepDeclare(sloupBaseView, numIndexes, 'numIndexes);sloupedGauge :=    {viewBounds: {left: 109, top: 100, right: 206, bottom: 113},     viewSetupFormScript:       func()       begin       	if sloupSpec.totalRecords       	then maxValue := sloupSpec.totalRecords;       	minValue := viewValue := 0;       end,     viewValue: 0,     _proto: @182 /* protoGauge */    };AddStepForm(sloupBaseView, sloupedGauge);StepDeclare(sloupBaseView, sloupedGauge, 'sloupedGauge);currentEntryLabel :=    {text: "Entry:",     viewBounds: {left: 2, top: 103, right: 44, bottom: 115},     _proto: @218 /* protoStaticText */    };AddStepForm(sloupBaseView, currentEntryLabel);// After Script for currentEntryLabelthisView := currentEntryLabel;begin	thisView.text := LocObj("Entry", 'entryLabel) & $:;endcurrentEntryDisplay :=    {viewBounds: {left: 2, top: 115, right: 206, bottom: 142},     viewFlags: 35,     viewFont: simpleFont9,     viewFormat: 337,     viewLineSpacing: 13,     viewClass: 81 /* clParagraphView */    };AddStepForm(sloupBaseView, currentEntryDisplay);StepDeclare(sloupBaseView, currentEntryDisplay, 'currentEntryDisplay);soundPicker :=    {text: "Sound",     viewBounds: {left: 0, top: 145, right: 100, bottom: 159},     prefSym: 'soundSym,     labelCommands: [],     viewJustify: 8388624,     viewSetupFormScript:       func()       begin       	labelCommands := [LocObj("none", 'noItem), 'pickSeparator,];       	if kBuild20       	then ArrayMunger(labelCommands,2,0, SoundList(),0,nil)       	else begin       		local slot,val;       		foreach slot,val in ROM_soundoff       		do AddArraySlot(labelCommands, {       			item: if kBuild20 or val.userName then val.userName else SPrintObject(slot),       			soundSymbol: slot});       		end;       	inherited:?viewSetupFormScript();       end,     textSetup:       func()       begin       	local soundSym := prefsCurrent.(prefSym), val;       	if soundSym       	then if (val := if kBuild20 then GetRegisteredSound(soundSym) else ROM_soundoff.(soundSym))       			and val.userName       		then val.userName       		else SPrintObject(soundSym)       	else labelCommands[0];       end,     labelActionScript:       func(cmd)       begin       	local sel := labelCommands[cmd];       	local sym := if cmd > 0 then sel.soundSymbol;       	:setPreference(prefSym, sym);       	if sym       	then begin       		PlaySound(if kBuild20 then GetRegisteredSound(sym) else ROM_soundoff.(sym));       		if kBuild1x then :updateText(sel.item);       		end;       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(sloupBaseView, soundPicker);// After Script for soundPickerthisView := soundPicker;begin	thisView.text := LocObj("Sound", 'soundLabel);	if kBuild20	then begin		thisView.viewBounds.left := 25;		thisView.viewBounds.right := thisView.viewBounds.right + 25;		end;endconnectCheck :=    {text: "AutoConn?",     viewBounds: {left: 2, top: 159, right: 90, bottom: 171},     valueChanged:       func()       begin       	inherited:valueChanged();       	if viewValue and not commEndPt       	then :epConnect()       	else if not viewValue and commEndPt       	then :epDisconnect();       end,     prefSym: 'connect,     _proto: _v164_0    };AddStepForm(sloupBaseView, connectCheck);// After Script for connectCheckthisView := connectCheck;begin	thisView.text := LocObj("AutoConnect", 'autoConnLabel) & $?;endrefreshCheck :=    {text: "Refresh?",     viewBounds: {left: -73, top: 159, right: -18, bottom: 171},     viewJustify: 36     ,     prefSym: 'refresh,     _proto: _v164_0    };AddStepForm(sloupBaseView, refreshCheck);// After Script for refreshCheckthisView := refreshCheck;begin	thisView.text := LocObj("Refresh", 'refreshLabel) & $?;	local vb := thisView.viewBounds;	if kBuild20	then vb.left := vb.left-20;	// !!!gendaboutView := LinkedSubview(_v180_0,    {viewBounds: {left: 139, top: 33, right: 163, bottom: 49}});AddStepForm(sloupBaseView, aboutView);StepDeclare(sloupBaseView, aboutView, 'aboutView);encodingButton :=    {     buttonClickScript:       func()       //if kAddEncoding then       OpenPrefsTo({       	_proto:				GetGlobalVar(kNewtsCapeSymbol).protos.NTE_protoPrefsRollItem, // !!!d       	overview:			kAppName,       	defaultEncoding:	kDefaultEncoding,       	//classSpec:		{subClass: 'string},              	viewSetupFormScript: func()       		begin       			appPrefs := GetRoot().(kAppSymbol).prefsEntry; //GetAppPrefs(kAppSymbol, {})       			if appPrefs.NTEncoding = nil       			then appPrefs.NTEncoding := {};       			self.prefs := appPrefs.NTEncoding;       			inherited:?viewSetupFormScript();       		end,                     	viewQuitScript: func()       		begin       			EntryChangeXmit(appPrefs, nil);       			inherited:?viewQuitScript();       		end,       	}),     viewBounds: {left: 2, top: 146, right: 74, bottom: 157},     viewSetupFormScript:       func()       begin       	local gData := GetGlobalVar(kNewtsCapeSymbol);	// !!!d       	if not (gData and gData.protos and gData.protos.NTE_protoBasicEndPoint)       	then viewFlags := 0;       	inherited:?viewSetupFormScript();       end,     _proto: @226 /* protoTextButton */    };AddStepForm(sloupBaseView, encodingButton);// After Script for encodingButtonthisView := encodingButton;thisView.text := LocObj("Encoding", 'encodingItem);hideBox :=    {     buttonClickScript:       func() // !!!g       begin       	local root := GetRoot(), app := root.(kAppSymbol);       	if not app.hideObj       	then app.hideObj := root.notifyIcon:?AddAction(       				kAppName, func() GetRoot().(kAppSymbol):open(), nil);       	app:hide();       end,     viewTransferMode: 1,     viewFormat: 2,     viewSetupFormScript:       func()       begin       	if not GlobalFnExists('PackRGB)	// 2.0       	then viewBounds := OffsetRect(_proto.viewBounds,1,1);       	inherited:?viewSetupFormScript();       end,     viewBounds: {left: -30, top: -16, right: -17, bottom: -3},     _proto: @166 /* protoCloseBox */    };AddStepForm(sloupBaseView, hideBox);// After Script for hideBoxthisView := hideBox;begin	thisView.icon := @14;end// After Script for sloupBaseViewthisView := sloupBaseView;beginif kProfileOn then profilingOn := NIL;thisView.errorStatus := thisView.setStatus;	// !!!aif kBuild20then begin // just use default drag	thisView._proto := protoDragNGo;	RemoveSlot(thisView, 'viewClickScript);	//RemoveSlot(thisView, 'viewFlags);		// !!!c	RemoveSlot(thisView, 'viewDrawScript);	thisView.viewFormat := Bor(thisView.viewFormat, 208); //vfFrameDragger);	// !!!a. leave in since public 2.x	//RemoveSlot(thisView, 'sharewareFee);	//ArrayRemoveCount(thisView.stepChildren, 0, 1); // registerButton	endelse begin	//thisView.registerButton := NIL;	thisView.viewFormat := Bor(thisView.viewFormat, vfFrameMatte);	//RemoveSlot(thisView, 'reloFix);	SetLength(thisView.bpsOptions, kItemLen);	if not kAll	then RemoveSlot(thisView, 'NetworkChooserDone);	// !!!a	ArrayRemoveCount(thisView.stepChildren, Length(thisView.stepChildren)-1, 1); // !!!g. hideBox	RemoveSlot(thisView, 'viewShowScript);	end;thisView.protoSerialProtocol.configOptions[3].data :=	thisView.protoSerialProtocol.configOptions[2].data; // shareif kNewEndPointthen RemoveSlot(thisView.protoSerialProtocol.firstLineSpec, 'byteCount)else begin	RemoveSlot(thisView.protoSerialProtocol, 'flushOutput);	// protoEndpoint directly	RemoveSlot(thisView.protoSerialProtocol.firstLineSpec, 'termination);	thisView.protoSerialProtocol.firstLineSpec.InputScript :=	// use method directly		thisView.protoSerialProtocol.firstLineSpec.lineScript;	RemoveSlot(thisView.protoSerialProtocol.firstLineSpec, 'lineScript);	local cleanFn := func(options)	begin		local option;		foreach option in options		do begin			RemoveSlot(option, 'result);			RemoveSlot(option, 'form);			end;	end;	call cleanFn with (thisView.protoSerialProtocol.configOptions);	if kAll then call cleanFn with (thisView.bpsOptions[kMNPitem]);	end;if kBuild1xthen begin	// !!!d. for kBuild20, hide if appropriate	local children := thisView.stepChildren;	ArrayRemoveCount(children, Length(children)-1, 1);	// -encoding	end;endconstant |layout_SloupBaseView.t| := sloupBaseView;// End of file SloupBaseView.t